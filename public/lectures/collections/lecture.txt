
ğŸ“ Zbirke podataka u Javi

Comparator, Sortiranje i moderne tehnike

ğŸ“‹ SadrÅ¾aj vjeÅ¾bi

KlasiÄni pristupi

Comparator suÄelje
Implementacija Comparatora
TreeSet sa sortiranjem
Enumeracije u praksi

Moderni pristupi

Lambda izrazi za usporedbu
Method references
Comparator.comparing()
Sortiranje po viÅ¡e kriterija
Stream API operacije

âš–ï¸ SuÄelje Comparator

Comparator omoguÄ‡ava definiranje specifiÄnih kriterija sortiranja za objekte.

KljuÄne karakteristike:

Funkcionalno suÄelje â€“ ima samo jednu apstraktnu metodu (compare)
Idealno za lambda izraze
OmoguÄ‡ava viÅ¡estruke kriterije sortiranja za istu klasu
Koristi se s Collections.sort(), Stream.sorted(), TreeSet

@FunctionalInterface
public interface Comparator<T> {
int compare(T o1, T o2);
// VraÄ‡a: negativan (o1 < o2), 0 (jednaki), pozitivan (o1 > o2)
}

ğŸ‘¨â€ğŸ“ Student klasa - Primjer

public class Student {
private String prezime;
private String ime;
private String jmbag;
private double prosjek;
Â 
// Konstruktor
public Student(String prezime, String ime,
String jmbag, double prosjek) {
this.prezime = prezime;
this.ime = ime;
this.jmbag = jmbag;
this.prosjek = prosjek;
}
Â 
// Getteri i setteri...
Â 
@Override
public String toString() {
return prezime + " " + ime + "(" + prosjek + ")";
}
}

KlasiÄna implementacija Comparatora

âŒ Stari naÄin (verbose)

public class ProsjekSorter
implements Comparator<Student> {
Â 
@Override
public int compare(Student st1,
Student st2) {
if(st1.getProsjek() >
st2.getProsjek()) {
return 1;
}
else if (st1.getProsjek() <
st2.getProsjek()) {
return -1;
}
else {
return 0;
}
}
}

âœ… Moderni naÄin (Java 8+) BEST PRACTICE

// Lambda izraz
Comparator<Student> poProsjeku =
(s1, s2) -> Double.compare(
s1.getProsjek(),
s2.getProsjek()
);
Â 
// JoÅ¡ bolje - Comparator.comparing()
Comparator<Student> poProsjeku =
Comparator.comparingDouble(
Student::getProsjek
);

Primjer sortiranja liste

// Kreiranje studenata
Student prvi = new Student("PeriÄ‡", "Pero", "0240293832", 4.11);
Student drugi = new Student("IviÄ‡", "Ivo", "0240212322", 3.82);
Student treci = new Student("MarkiÄ‡", "Marko", "0240297890", 4.78);
Student cetvrti = new Student("Horvat", "Ivan", "0240294345", 3.05);
Â 
// Kreiranje liste
List<Student> listaStudenata = new ArrayList<>();
listaStudenata.add(prvi);
listaStudenata.add(drugi);
listaStudenata.add(treci);
listaStudenata.add(cetvrti);
Â 
// Sortiranje - moderni naÄin
listaStudenata.sort(Comparator.comparingDouble(Student::getProsjek));
Â 
System.out.println(listaStudenata);
// [Horvat Ivan(3.05), IviÄ‡ Ivo(3.82), PeriÄ‡ Pero(4.11), MarkiÄ‡ Marko(4.78)]

TreeSet s Comparatorom

TreeSet automatski sortira elemente prema Comparatoru ili natural ordering.

// TreeSet s custom comparatorom
SortedSet<Student> setStudenata = new TreeSet<>(
Comparator.comparingDouble(Student::getProsjek)
);
Â 
setStudenata.add(prvi);
setStudenata.add(drugi);
setStudenata.add(treci);
setStudenata.add(cetvrti);
Â 
System.out.println("Najbolji: " + setStudenata.last());
System.out.println("Najgori: " + setStudenata.first());
Â 
// Ispis:
// Najbolji: MarkiÄ‡ Marko(4.78)
// Najgori: Horvat Ivan(3.05)

Java 21 - SequencedSet s TreeSet JAVA 21

Od Java 21, TreeSet implementira SequencedSet za bolji pristup prvom/zadnjem!

// Java 21 - SequencedSet API
SequencedSet<Student> setStudenata = new TreeSet<>(
Comparator.comparingDouble(Student::getProsjek)
);
Â 
setStudenata.add(prvi);
setStudenata.add(drugi);
setStudenata.add(treci);
setStudenata.add(cetvrti);
Â 
// Nove metode iz Java 21!
Student najbolji = setStudenata.getLast();  // Direktno!
Student najgori = setStudenata.getFirst(); // Direktno!
Â 
// Obrnuti redoslijed
SequencedSet<Student> obrnuto = setStudenata.reversed();

Sortiranje po viÅ¡e kriterija
Problem: Studenti s istim prosjekom

Student prvi = new Student("PeriÄ‡", "Pero", "0240293832", 4.11);
Student drugi = new Student("IviÄ‡", "Ivo", "0240212322", 4.11);
Student treci = new Student("MarkiÄ‡", "Marko", "0240297890", 4.11);
Student cetvrti = new Student("Horvat", "Ivan", "0240294345", 4.11);
Â 
// Svi imaju isti prosjek - trebamo sortirat i po prezimenu!

âš ï¸ Trebamo sortirati prvo po prosjeku, a onda po prezimenu!

ViÅ¡ekriterijsko sortiranje - Moderni pristup

List<Student> listaStudenata = new ArrayList<>();
listaStudenata.add(prvi);
listaStudenata.add(drugi);
listaStudenata.add(treci);
listaStudenata.add(cetvrti);
Â 
// Java 8+ naÄin - jednostavno!
Comparator<Student> poProsjekuIPrezimenu =
Comparator.comparingDouble(Student::getProsjek)
.thenComparing(Student::getPrezime);
Â 
listaStudenata.stream()
.sorted(poProsjekuIPrezimenu)
.forEach(System.out::println);
Â 
// Ispis: Horvat Ivan(4.11), IviÄ‡ Ivo(4.11),
//        MarkiÄ‡ Marko(4.11), PeriÄ‡ Pero(4.11)

ğŸ› ï¸ Comparator - Korisne metode (Java 8+)

Kreiranje Comparatora:

comparing()
comparingInt()
comparingDouble()
comparingLong()
naturalOrder()
reverseOrder()

Kombiniranje:

thenComparing()
thenComparingInt()
thenComparingDouble()
reversed()
nullsFirst()
nullsLast()

// Kompleksni primjer
Comparator<Student> kompleksni =
Comparator.comparingDouble(Student::getProsjek)
.reversed()  // Silazno po prosjeku
.thenComparing(Student::getPrezime)  // Pa uzlazno po prezimenu
.thenComparing(Student::getIme);      // Pa po imenu

ğŸ›ï¸ Enumeracije - Primjer sa Å½upanijama

public enum Zupanija {
Â 
ZAGREBACKA("1", "ZagrebaÄka", 309696, 3078.0),
PRIMORSKO_GORANSKA("051", "Primorsko-goranska",
305505, 3590.0),
SPLITSKO_DALMATINSKA("021", "Splitsko-dalmatinska",
463676, 4524.0),
GRAD_ZAGREB("01", "Grad Zagreb", 779145, 641.0);
Â 
private final String pozivniBroj;
private final String naziv;
private final int brojStanovnika;
private final double povrsina;
Â 
Zupanija(String pozivniBroj, String naziv,
int brojStanovnika, double povrsina) {
this.pozivniBroj = pozivniBroj;
this.naziv = naziv;
this.brojStanovnika = brojStanovnika;
this.povrsina = povrsina;
}
// Getteri...
}

Comparator za gustoÄ‡u naseljenosti

âŒ KlasiÄni naÄin

public class GustocaComparator
implements Comparator<Zupanija> {
Â 
@Override
public int compare(Zupanija z1,
Zupanija z2) {
double gustoca1 =
z1.getBrojStanovnika() /
z1.getPovrsina();
double gustoca2 =
z2.getBrojStanovnika() /
z2.getPovrsina();
Â 
return Double.compare(
gustoca2, gustoca1);
}
}

âœ… Moderni naÄin (Java 8+)

// Lambda + metoda za gustoÄ‡u
Comparator<Zupanija> poGustoci =
Comparator.comparingDouble(
z -> z.getBrojStanovnika() /
z.getPovrsina()
).reversed();
Â 
// Ili s helper metodom
Comparator<Zupanija> poGustoci2 =
Comparator.comparingDouble(
Zupanija::gustocaNaseljenosti
).reversed();

ğŸŒŠ Stream operacije s enumeracijama

// Top 5 Å¾upanija po gustoÄ‡i naseljenosti
List<Zupanija> top5 = Arrays.stream(Zupanija.values())
.sorted(Comparator.comparingDouble(
z -> z.getBrojStanovnika() / z.getPovrsina()
).reversed())
.limit(5)
.toList();  // Java 17+
Â 
top5.forEach(System.out::println);
Â 
// ProsjeÄna gustoÄ‡a svih Å¾upanija
double prosjekGustoca = Arrays.stream(Zupanija.values())
.mapToDouble(z -> z.getBrojStanovnika() / z.getPovrsina())
.average()
.orElse(0.0);
Â 
System.out.println("ProsjeÄna gustoÄ‡a: " + prosjekGustoca);

Java 24 - Stream Gatherers JAVA 24
Grupiranje Å¾upanija po regijama

// Grupiranje Å¾upanija u grupe od po 5 (regije)
List<List<Zupanija>> regije = Arrays.stream(Zupanija.values())
.sorted(Comparator.comparing(Zupanija::getNaziv))
.gather(Gatherers.windowFixed(5))
.toList();
Â 
// IspiÅ¡i regije
int regionIndex = 1;
for (List<Zupanija> regija : regije) {
System.out.println("Regija " + regionIndex++ + ":");
regija.forEach(z -> System.out.println("  - " +
z.getNaziv()));
}

ğŸ’¡ Gatherers omoguÄ‡avaju custom intermediate operacije koje prije nisu bile moguÄ‡e!

ğŸ“Š StatistiÄke analize sa Stream API

// DoubleSummaryStatistics - sveobuhvatna statistika
DoubleSummaryStatistics stats =
Arrays.stream(Zupanija.values())
.mapToDouble(z -> z.getBrojStanovnika() / z.getPovrsina())
.summaryStatistics();
Â 
System.out.println("Broj Å¾upanija: " + stats.getCount());
System.out.println("Minimalna gustoÄ‡a: " + stats.getMin());
System.out.println("Maksimalna gustoÄ‡a: " + stats.getMax());
System.out.println("ProsjeÄna gustoÄ‡a: " + stats.getAverage());
System.out.println("Suma: " + stats.getSum());
Â 
// Å½upanije iznad prosjeka
double prosjek = stats.getAverage();
List<Zupanija> iznadProsjeka = Arrays.stream(Zupanija.values())
.filter(z -> (z.getBrojStanovnika() / z.getPovrsina()) > prosjek)
.toList();

Grupiranje s Collectors.groupingBy()

// Grupiraj studente po prosjeku (cijeli broj)
Map<Integer, List<Student>> studentiPoProsjeku =
listaStudenata.stream()
.collect(Collectors.groupingBy(
s -> (int) s.getProsjek()
));
Â 
// IspiÅ¡i grupe
studentiPoProsjeku.forEach((prosjek, studenti) -> {
System.out.println("Prosjek " + prosjek + ":");
studenti.forEach(s -> System.out.println("  " + s));
});
Â 
// Broj studenata po prosjeku
Map<Integer, Long> brojStudenata =
listaStudenata.stream()
.collect(Collectors.groupingBy(
s -> (int) s.getProsjek(),
Collectors.counting()
));

Particioniranje s Collectors.partitioningBy()

// Particioniraj studente - odlikaÅ¡i vs ostali
Map<Boolean, List<Student>> particionirano =
listaStudenata.stream()
.collect(Collectors.partitioningBy(
s -> s.getProsjek() >= 4.5
));
Â 
System.out.println("OdlikaÅ¡i:");
particionirano.get(true).forEach(System.out::println);
Â 
System.out.println("\nOstali:");
particionirano.get(false).forEach(System.out::println);
Â 
// Broj studenata u svakoj grupi
Map<Boolean, Long> brojevi =
listaStudenata.stream()
.collect(Collectors.partitioningBy(
s -> s.getProsjek() >= 4.5,
Collectors.counting()
));

ğŸ’¡ Best Practices

âœ… Radi ovo:

Koristi Comparator.comparing()
Koristi method references
Koristi thenComparing() za viÅ¡e kriterija
Koristi Stream API
Koristi lambda izraze
Koristi toList() (Java 17+)

âŒ Izbjegavaj:

Vlastite Comparator klase kad nije potrebno
RuÄno implementiranje compare()
Collections.sort() - koristi List.sort()
if-else u compare metodi
ZbunjujuÄ‡u logiku sortiranja

ğŸ“š SaÅ¾etak

KljuÄne tehnike:

Comparator - funkcionalno suÄelje za custom sortiranje
Lambda izrazi - kraÄ‡i i Äitljiviji kod
Method references - joÅ¡ kraÄ‡i kod
Comparator.comparing() - standardni naÄin kreiranja Comparatora
thenComparing() - viÅ¡ekriterijsko sortiranje
Stream API - funkcionalna obrada kolekcija
Collectors - groupingBy, partitioningBy
SequencedSet (Java 21) - bolji pristup sortiranim setovima
Gatherers (Java 24) - custom intermediate operacije

ğŸš€ Moderne Java funkcionalnosti

Java 8: Lambda, Stream API, Method references, Comparator.comparing()
Java 9: Factory metode (List.of, Set.of)
Java 10: var keyword
Java 17 LTS: Stream.toList()
Java 21 LTS: Sequenced Collections
Java 24: Stream Gatherers
Java 25 LTS: Compact Headers, Performance improvements

Uvijek koristite najnovije verzije Java LTS-a!
Trenutno: Java 21 LTS ili Java 25 LTS


Osnovni koncepti

Uvod u zbirke podataka
Collection suÄelje
Liste, Setovi, Mape
Enumeracije

Moderne funkcionalnosti

Stream API (Java 8+)
Immutable kolekcije (Java 9+)
Stream.toList() (Java 17)
Sequenced Collections (Java 21)
Stream Gatherers (Java 24) ğŸ¯
Performance (Java 25 LTS) âš¡

ğŸ—‚ï¸ Å to su zbirke podataka?

Zbirka (Collection) je objektna struktura podataka koja moÅ¾e sadrÅ¾avati reference drugih objekata.

Glavna suÄelja u Java Collections Framework:

Collection â€“ osnovno suÄelje za sve zbirke
List â€“ dopuÅ¡ta duplikate, Äuva redoslijed
Set â€“ ne dopuÅ¡ta duplikate
Map â€“ pohranjuje parove "kljuÄ-vrijednost"

âš ï¸ VaÅ¾no: Zbirke ne mogu sadrÅ¾avati primitivne tipove! Koristi se autoboxing (npr. int â†’ Integer)

ğŸ“ Liste (List interface)
Karakteristike:

Poredana zbirka koja Äuva redoslijed elemenata
MoÅ¾e sadrÅ¾avati duplikate
Pristup elementima putem indeksa

NajÄeÅ¡Ä‡e implementacije:

ArrayList
âœ… Brzo dohvaÄ‡anje po indeksu
âŒ Sporije umetanje/brisanje
ğŸ’¡ Najbolji za Äitanje

LinkedList
âœ… Brzo umetanje/brisanje
âŒ Sporije dohvaÄ‡anje
ğŸ’¡ Najbolji za Äeste izmjene

ArrayList - Primjer sa strukturom blokova

// Diamond operator (<>) - od Java 7
List<String> godisnjaDoba = new ArrayList<>();
Â 
// Dodavanje elemenata
godisnjaDoba.add("ProljeÄ‡e");
godisnjaDoba.add("Ljeto");
godisnjaDoba.add("Jesen");
godisnjaDoba.add("Zima");
Â 
// For-each petlja (od Java 5)
for (String doba : godisnjaDoba) {
System.out.println(doba);
}
Â 
// DohvaÄ‡anje elementa po indeksu
String prvo = godisnjaDoba.get(0); // "ProljeÄ‡e"

UgnijeÅ¾Ä‘eni blokovi - Jasna struktura

List<Integer> brojevi = Arrays.asList(1, 2, 3, 4, 5);
Â 
for (Integer broj : brojevi) {
Â 
if (broj % 2 == 0) {
System.out.println("Paran: " + broj);
}
else {
System.out.println("Neparan: " + broj);
}
}
Â 
// Vertikalne linije pokazuju hijerarhiju blokova!

ğŸ¯ Setovi (Set interface)
Karakteristike:

Bez duplikata â€“ svaki element moÅ¾e biti samo jednom
Ne Äuva nuÅ¾no redoslijed umetanja
Brzo provjera postoji li element

Set<String> jedinstvenaImena = new HashSet<>();
Â 
jedinstvenaImena.add("Ana");
jedinstvenaImena.add("Marko");
jedinstvenaImena.add("Ana"); // NeÄ‡e se dodati!
Â 
System.out.println(jedinstvenaImena.size()); // 2

ğŸ—ºï¸ Mape (Map interface)

Map<String, Integer> brojStudenata = new HashMap<>();
Â 
// Dodavanje parova
brojStudenata.put("FER", 1500);
brojStudenata.put("PMF", 1200);
brojStudenata.put("TVZ", 800);
Â 
// DohvaÄ‡anje vrijednosti
Integer ferStudenti = brojStudenata.get("FER");
Â 
// Iteracija kroz sve parove
for (String fakultet : brojStudenata.keySet()) {
System.out.println(fakultet + ": " +
brojStudenata.get(fakultet));
}

ğŸ› ï¸ Collections utility klasa
SadrÅ¾i statiÄke metode za rad sa zbirkama:

Algoritmi:

sort() â€“ sortiranje
shuffle() â€“ mijeÅ¡anje
reverse() â€“ obrat
binarySearch() â€“ pretraÅ¾ivanje

Utility metode:

min(), max()
frequency() â€“ brojanje
copy() â€“ kopiranje
fill() â€“ popunjavanje

List<Integer> brojevi = Arrays.asList(5, 2, 8, 1, 9);
Â 
Collections.sort(brojevi);    // [1, 2, 5, 8, 9]
Collections.reverse(brojevi); // [9, 8, 5, 2, 1]
Â 
Integer max = Collections.max(brojevi); // 9

ğŸ·ï¸ Enumeracije (Enum)

Jednostavna enum:

public enum GodisnjeDoba {
PROLJECE,
LJETO,
JESEN,
ZIMA
}

Enum s poljima:

public enum Status {
USPJEH(1, "OK"),
GRESKA(2, "Fail");
Â 
private final int kod;
private final String opis;
Â 
Status(int kod, String opis) {
this.kod = kod;
this.opis = opis;
}
}

ğŸŒŠ Stream API (Java 8)
Å to su tokovi (Streams)?

OmoguÄ‡avaju funkcionalno programiranje u Javi
Deklarativna obrada podataka (kaÅ¾emo "Å¡to" ne "kako")
PodrÅ¾avaju paralelno procesiranje
Lenivo evaluiranje (lazy evaluation)

List<Integer> brojevi = Arrays.asList(1, 2, 3, 4, 5);
Â 
// Tradicionalni pristup
int suma = 0;
for (Integer broj : brojevi) {
if (broj % 2 == 0) {
suma += broj;
}
}
Â 
// Stream API pristup
int suma = brojevi.stream()
.filter(b -> b % 2 == 0)
.mapToInt(Integer::intValue)
.sum();

Stream operacije

âš™ï¸ MeÄ‘uoperacije

filter() â€“ filtriranje
map() â€“ transformacija
distinct() â€“ ukloni duplikate
sorted() â€“ sortiranje
limit() â€“ ograniÄi broj

ğŸ¯ ZavrÅ¡ne operacije

forEach() â€“ obradi sve
collect() â€“ skupi rezultate
count() â€“ broji elemente
reduce() â€“ reduciraj
findFirst() â€“ prvi element

Stream API - Primjer sa strukturom

class Student {
String ime;
int ocjena;
// konstruktor, getteri...
}
Â 
List<Student> studenti = Arrays.asList(
new Student("Ana", 5),
new Student("Marko", 3),
new Student("Ivana", 4)
);
Â 
// PronaÄ‘i imena studenata s ocjenom 5
List<String> odlikasi = studenti.stream()
.filter(s -> s.getOcjena() == 5)
.map(Student::getIme)
.sorted()
.collect(Collectors.toList());

Java 9 - Factory metode JAVA 9
Jednostavno kreiranje immutable kolekcija:

// Prije Java 9 - komplicirano ğŸ˜“
List<String> lista = new ArrayList<>();
lista.add("A");
lista.add("B");
lista = Collections.unmodifiableList(lista);
Â 
// Java 9 - jednostavno! ğŸ‰
List<String> lista = List.of("A", "B", "C");
Set<Integer> set = Set.of(1, 2, 3);
Map<String, Integer> mapa = Map.of(
"Ana", 25,
"Marko", 30
);
Â 
// PokuÅ¡aj izmjene baca iznimku!
lista.add("D"); // UnsupportedOperationException

Java 17 - Stream.toList() JAVA 17
KraÄ‡i i Äitljiviji kod!

List<String> imena = List.of("Ana", "Marko", "Ivana");
Â 
// Prije Java 17 - verbose
List<String> velkaSlova1 = imena.stream()
.map(String::toUpperCase)
.collect(Collectors.toList());
Â 
// Java 17 - jednostavnije! ğŸ¯
List<String> velkaSlova2 = imena.stream()
.map(String::toUpperCase)
.toList();

Java 21 - Sequenced Collections JAVA 21 LTS
NajveÄ‡a novost u Collections Frameworku!

Problem: Dosad nije bilo konzistentnog naÄina za pristup prvom/zadnjem elementu

// Lista sada ima konzistentan API
List<String> lista = new ArrayList<>();
Â 
lista.addFirst("Prvi");      // Dodaj na poÄetak
lista.addLast("Zadnji");    // Dodaj na kraj
Â 
String prvi = lista.getFirst();
String zadnji = lista.getLast();
Â 
// Obrnuti redoslijed - nova moguÄ‡nost!
List<String> obrnuto = lista.reversed();

Java 24 - Stream Gatherers JAVA 24
Custom intermediate operations za Stream!

Problem: Stream API nema sve potrebne meÄ‘uoperacije (npr. batching, windowing)

Novi ugraÄ‘eni Gatherers:

windowFixed(n) â€“ podijeli u grupe fiksne veliÄine
windowSliding(n) â€“ klizni prozor
fold() â€“ sloÅ¾ena redukcija
scan() â€“ akumulacija s meÄ‘urezultatima
mapConcurrent() â€“ konkurentna obrada

Stream Gatherers - Primjer

// Podjela u grupe od po 3 elementa
List<Integer> brojevi = List.of(1, 2, 3, 4, 5, 6, 7);
Â 
List<List<Integer>> grupe = brojevi.stream()
.gather(Gatherers.windowFixed(3))
.toList();
// [[1, 2, 3], [4, 5, 6], [7]]
Â 
// Klizni prozor veliÄine 2
List<List<Integer>> prozori = brojevi.stream()
.gather(Gatherers.windowSliding(2))
.toList();
// [[1,2], [2,3], [3,4], [4,5], [5,6], [6,7]]
Â 
// Konkurentna transformacija (max 3 paralelna)
List<String> rezultati = brojevi.stream()
.gather(Gatherers.mapConcurrent(3,
n -> "ObraÄ‘eno: " + n))
.toList();

Java 25 - Performance & Memory JAVA 25 LTS
ğŸš€ Compact Object Headers (JEP 519)

Smanjenje memorijskog footprinta za 50%!
Header objekta: 128 bitova â†’ 64 bita

âœ… Automatski aktivno u Java 25 (ne treba nikakva konfiguracija)
âœ… Posebno uÄinkovito za aplikacije s puno malih objekata
âœ… Smanjuje broj GC ciklusa
ğŸ’¡ Idealno za microservices i cloud deploymente

// Primjer: Lista od milijun malih objekata
List<Point> tocke = new ArrayList<>();
for (int i = 0; i < 1_000_000; i++) {
tocke.add(new Point(i, i));
}
// Java 24: ~48 MB memorije
// Java 25: ~32 MB memorije âš¡

Java 25 - Generational Shenandoah JAVA 25 LTS
âš¡ PoboljÅ¡ani Garbage Collector (JEP 521)

Low-latency GC s generacijskim pristupom
Dijeli heap na young i old generaciju
Bolje performanse za aplikacije s puno kratkoÅ¾iveÄ‡ih objekata
Manji pause times (<10ms)

// Pokretanje s Generational Shenandoah
java -XX:+UseShenandoahGC \
-XX:ShenandoahGCMode=generational \
MojaAplikacija
Â 
// ViÅ¡e ne treba -XX:+UnlockExperimentalVMOptions!

ğŸ’¡ Kada koristiti: Latency-sensitive aplikacije (web serveri, real-time sustavi)

Java 25 - Flexible Constructor Bodies JAVA 25
OmoguÄ‡ava kod PRIJE super() poziva!

class Rectangle extends Shape {
final int width;
final int height;
Â 
public Rectangle(int width, int height) {
// Java 25: Validacija PRIJE super()! ğŸ‰
if (width <= 0 || height <= 0) {
throw new IllegalArgumentException(
"Dimenzije moraju biti pozitivne");
}
Â 
// RaÄunanje prije super()
int area = width * height;
Â 
super(area); // Sada je moguÄ‡e!
Â 
this.width = width;
this.height = height;
}
}

Java 25 - Module Import Declarations JAVA 25
Import cijelog modula odjednom!

// Prije Java 25 - mnogobrojna importanja
import java.util.Map;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.function.Function;
Â 
// Java 25 - import cijelog modula ğŸ¯
import module java.base;
// Sve klase iz java.base modula su dostupne!

ğŸ’¡ Koristi se za manje projekte, prototipove ili skripte

ğŸ’¡ Best Practices

âœ… Radi ovo:

Koristi suÄelja kao tipove
Koristi diamond operator
Koristi Stream API
Koristi immutable kolekcije
Koristi var (Java 10+)
Koristi Gatherers (Java 24+)

âŒ Izbjegavaj:

Konkretne implementacije kao tipove
Ponavljanje tipova
RuÄno pisanje petlji
Mijenjanje tijekom iteracije
Null vrijednosti u zbirkama

ğŸ“š SaÅ¾etak - Evolution of Java Collections

Java 5: Generics, For-each, Enums
Java 7: Diamond operator (<>)
Java 8: ğŸŒŠ Stream API, Lambda izrazi
Java 9: ğŸ­ Factory metode (List.of, Set.of, Map.of)
Java 10: ğŸ¯ Var keyword
Java 17 LTS: âœ¨ Stream.toList()
Java 21 LTS: ğŸ“Š Sequenced Collections
Java 24: ğŸ¨ Stream Gatherers
Java 25 LTS: âš¡ Compact Headers, Generational Shenandoah, Flexible Constructors

Java 25 je najnoviji LTS release!
SljedeÄ‡i LTS: Java 29 (2027)

Napredak kroz verzije - Primjer

// Java 8 - verbose
List<String> rezultat = brojevi.stream()
.filter(n -> n % 2 == 0)
.map(String::valueOf)
.collect(Collectors.toList());
Â 
// Java 17 - jednostavnije
List<String> rezultat = brojevi.stream()
.filter(n -> n % 2 == 0)
.map(String::valueOf)
.toList();
Â 
// Java 24 - s grupiranjem
List<List<Integer>> grupe = brojevi.stream()
.filter(n -> n % 2 == 0)
.gather(Gatherers.windowFixed(3))
.toList();

ğŸ”— Korisni resursi

Dokumentacija:

Java 25 Documentation
JEP 431: Sequenced Collections
JEP 485: Stream Gatherers
Oracle Dev.java