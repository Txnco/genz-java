
â˜• Java 25 Edition

Exception Handling kao profesionalci

Osnove

Uvod u iznimke
Try-catch-finally
Multi-catch blok
Try-with-resources

Napredne teme

Hijerarhija iznimaka
Checked vs Unchecked
Bacanje iznimaka
Vlastite iznimke

Ova prezentacija je interaktivna - koristite strelice ili klikove za navigaciju!

ğŸ¯ Å to su to iznimke?

Iznimka (Exception) je objekt koji predstavlja problem nastao tijekom izvoÄ‘enja programa.

ğŸ›¡ï¸ OmoguÄ‡avaju razvoj robusnih aplikacija
â™»ï¸ Program moÅ¾e nastaviti rad i nakon greÅ¡ke
ğŸ­ Predstavljene klasama koje nasljeÄ‘uju Throwable
ğŸ£ Mogu se hvatati (catch) i bacati (throw)

Exception handling nije samo za greÅ¡ke - koristi se i za kontrolu toka programa!

âŒ Problem: Bez obrade iznimki

public class BezObradeIznimke {
private static int podijeli(int djeljenik, int djelitelj) {
return djeljenik / djelitelj;  // âš ï¸ Å to ako je djelitelj 0?
}

public static void main(String[] args) {
Scanner unos = new Scanner(System.in);
System.out.print("Unesite dva broja: ");

int prvi = unos.nextInt();
int drugi = unos.nextInt();
int rezultat = podijeli(prvi, drugi);

System.out.println("Rezultat: " + rezultat);
unos.close();
}
}

Output (ako korisnik unese 5 i 0):
Exception in thread "main" java.lang.ArithmeticException: / by zero

ğŸ” Razumijevanje Stack Trace

Exception in thread "main" java.lang.ArithmeticException: / by zero
at BezObradeIznimke.podijeli(BezObradeIznimke.java:8)
at BezObradeIznimke.main(BezObradeIznimke.java:18)

Dio
Opis

java.lang.ArithmeticException
Naziv iznimke

/ by zero
Opisna poruka

at BezObradeIznimke.podijeli(...)
Lokacija gdje se dogodila iznimka

(BezObradeIznimke.java:8)
Datoteka i broj linije

âœ… RjeÅ¡enje: Try-Catch blok

boolean nastaviPetlju;
do {
nastaviPetlju = false;
try {
// RiziÄan kod koji moÅ¾e baciti iznimku
System.out.print("Unesite dva broja: ");
int prvi = unos.nextInt();
int drugi = unos.nextInt();
int rezultat = podijeli(prvi, drugi);
System.out.println("Rezultat: " + rezultat);

} catch (InputMismatchException ex) {
// Obrada pogreÅ¡nog unosa
System.out.println("âŒ Morate unijeti brojÄane vrijednosti!");
unos.nextLine();  // OÄisti buffer
nastaviPetlju = true;

} catch (ArithmeticException ex) {
// Obrada dijeljenja s nulom
System.out.println("âŒ Ne moÅ¾ete dijeliti s nulom!");
unos.nextLine();
nastaviPetlju = true;
}
} while (nastaviPetlju);

ğŸ”¬ Anatomija Try-Catch bloka

TRY blok
SadrÅ¾i kod koji moÅ¾e baciti iznimku. Izvodi se sve dok ne doÄ‘e do iznimke.

CATCH blok
SadrÅ¾i kod koji se izvodi samo ako se dogodi odreÄ‘ena iznimka.

MoÅ¾ete imati viÅ¡e catch blokova za razliÄite tipove iznimaka!

âš¡ Try se izvodi linearno do iznimke
ğŸ¯ Catch "hvata" samo svoj tip iznimke
ğŸ”„ Nakon catch-a program normalno nastavlja

ğŸ­ Multi-Catch blok Java 7+
Kada viÅ¡e iznimaka treba obraÄ‘ivati na isti naÄin:

âŒ Stari naÄin

catch (IOException ex) {
logger.log(ex);
showError();
}
catch (SQLException ex) {
logger.log(ex);
showError();
}

âœ… Novi naÄin

catch (IOException | SQLException ex) {
logger.log(ex);
showError();
}

Prednosti:

Manje dupliciranog koda
ÄŒitljiviji i koncizniji kod
LakÅ¡e odrÅ¾avanje

ğŸ¬ Finally Blok - Uvijek se izvrÅ¡ava!

FileReader reader = null;
try {
reader = new FileReader("data.txt");
// Rad s datotekom...

} catch (IOException ex) {
System.err.println("GreÅ¡ka Äitanja: " + ex.getMessage());

} finally {
// Ovo se UVIJEK izvrÅ¡ava - iznimka ili ne!
if (reader != null) {
try {
reader.close();
System.out.println("âœ… Datoteka zatvorena");
} catch (IOException e) {
e.printStackTrace();
}
}
}

Finally se izvrÅ¡ava: Nakon try bloka, nakon catch bloka, Äak i ako postoji return u try/catch!

ğŸš° Try-with-Resources Java 7+
Automatsko zatvaranje resursa - elegantnije i sigurnije!

âŒ Stari naÄin (verbozno)

BufferedReader br = null;
try {
br = new BufferedReader(
new FileReader("file.txt")
);
return br.readLine();
} finally {
if (br != null) {
br.close();
}
}

âœ… Novi naÄin (clean)

try (BufferedReader br =
new BufferedReader(
new FileReader("file.txt")
)) {
return br.readLine();
}
// Automatski zatvoreno! ğŸ‰

Radi s bilo kojom klasom koja implementira AutoCloseable interface!

ğŸŒ³ Hijerarhija iznimaka

java.lang.Throwable - Korijen svega

Exception - Iznimke koje treba obraÄ‘ivati

RuntimeException - NeoznaÄene iznimke

ArithmeticException
NullPointerException
IndexOutOfBoundsException

IOException - OznaÄene iznimke

FileNotFoundException
EOFException

Error - Ozbiljne greÅ¡ke (NE OBRAÄIVATI!)

OutOfMemoryError
StackOverflowError

ğŸ·ï¸ OznaÄene vs NeoznaÄene iznimke

âœ… Checked (OznaÄene)

NasljeÄ‘uju Exception
MORAJU se obraÄ‘ivati
Kompajler ih provjerava
Za predvidive probleme

IOException
SQLException
ClassNotFoundException

âš ï¸ Unchecked (NeoznaÄene)

NasljeÄ‘uju RuntimeException
Ne moraju se obraÄ‘ivati
Kompajler ih ne provjerava
Za programske greÅ¡ke

NullPointerException
ArithmeticException
ArrayIndexOutOfBoundsException

Pravilo: Ako moÅ¾ete sprijeÄiti u kodu - unchecked. Ako ovisi o vanjskim faktorima - checked.

ğŸ¾ Bacanje iznimaka - throw

public class Korisnik {
private String email;

public void setEmail(String email) {
// Validacija emaila
if (email == null || email.isEmpty()) {
throw new IllegalArgumentException(
"Email ne moÅ¾e biti prazan! ğŸ“§"
);
}

if (!email.contains("@")) {
throw new IllegalArgumentException(
"Email mora sadrÅ¾avati @"
);
}

this.email = email;
}
}

throw - baca novu iznimku (stvara objekt i prekida tok izvoÄ‘enja)

ğŸ“¢ Deklaracija iznimaka - throws
Za checked iznimke morate ili: (1) uhvatiti ih ili (2) deklarirati da ih metoda baca

public class FileManager {

// Metoda deklarira da baca IOException
public String readFile(String path)
throws IOException {

BufferedReader reader = new BufferedReader(
new FileReader(path)  // Baca IOException
);

return reader.readLine();  // TakoÄ‘er baca IOException
}

public void processFile() {
try {
String content = readFile("data.txt");
System.out.println(content);
} catch (IOException e) {
System.err.println("âŒ GreÅ¡ka: " + e.getMessage());
}
}
}

throws = "ova metoda moÅ¾e baciti ove iznimke, pa ih ti obradi"

ğŸ¨ Kreiranje vlastitih iznimaka

// Checked iznimka (nasljeÄ‘uje Exception)
public class InvalidEmailException extends Exception {

public InvalidEmailException() {
super("Email adresa nije valjana");
}

public InvalidEmailException(String message) {
super(message);
}

public InvalidEmailException(String message, Throwable cause) {
super(message, cause);
}

public InvalidEmailException(Throwable cause) {
super(cause);
}
}

Best Practice: Implementirajte sva 4 konstruktora za fleksibilnost!

ğŸ¯ KoriÅ¡tenje vlastite iznimke

public class EmailValidator {

public static void validateEmail(String email)
throws InvalidEmailException {

if (email == null || email.isEmpty()) {
throw new InvalidEmailException(
"Email ne smije biti prazan"
);
}

if (!email.matches("^[A-Za-z0-9+_.-]+@(.+)$")) {
throw new InvalidEmailException(
"Email format nije valjan: " + email
);
}
}

public static void main(String[] args) {
try {
validateEmail("korisnik@primjer.com");
System.out.println("âœ… Email je valjan!");

} catch (InvalidEmailException e) {
System.err.println("âŒ " + e.getMessage());
}
}
}

â­ Best Practices

âœ… RADI:

Hvati specifiÄne iznimke, ne Exception
Daj korisne poruke o greÅ¡kama
Koristi try-with-resources za resurse
Logiraj iznimke za debugging
Kreiraj vlastite iznimke za domensku logiku

âŒ NEMOJ:

Prazan catch blok (catch(Exception e) {})
Hvatati Error klasu
Koristiti iznimke za kontrolu toka
Ignorirati checked iznimke
Bacati generiÄke iznimke bez poruke

ğŸ†• Pattern Matching Java 21+
Moderne moguÄ‡nosti za obradu iznimaka:

public String handleException(Exception ex) {
return switch (ex) {
case FileNotFoundException fnf
when fnf.getMessage().contains("config") ->
"âš™ï¸ Konfiguracijska datoteka nije pronaÄ‘ena";

case FileNotFoundException fnf ->
"ğŸ“„ Datoteka nije pronaÄ‘ena: " + fnf.getMessage();

case IOException io ->
"ğŸ’¾ I/O greÅ¡ka: " + io.getMessage();

case SQLException sql ->
"ğŸ—ƒï¸ GreÅ¡ka baze podataka: " + sql.getMessage();

default ->
"âŒ Nepoznata greÅ¡ka: " + ex.getMessage();
};
}

Pattern matching omoguÄ‡ava elegantniju obradu razliÄitih tipova iznimaka!

â›“ï¸ Chained Exceptions
Povezivanje iznimaka za bolju dijagnostiku:

public class DataService {

public User getUser(int id) throws DataAccessException {
try {
// Spajanje na bazu i dohvaÄ‡anje korisnika
Connection conn = getConnection();
return fetchUserFromDB(conn, id);

} catch (SQLException e) {
// Omotaj SQL iznimku u domensku iznimku
throw new DataAccessException(
"Ne mogu dohvatiti korisnika #" + id,
e  // â† Originalna iznimka kao uzrok
);
}
}
}

Prednosti:

ZadrÅ¾ava potpunu informaciju o greÅ¡ki
OmoguÄ‡ava apstrakciju (skriva SQL detalje)
OlakÅ¡ava debugging (cijeli lanac je vidljiv)

ğŸ’¼ PraktiÄni primjer - API poziv

public class UserAPI {

public User createUser(String email, String password) {
try {
// Validacija
EmailValidator.validateEmail(email);
PasswordValidator.validatePassword(password);

// Provjera postoji li veÄ‡ korisnik
if (userRepository.existsByEmail(email)) {
throw new UserAlreadyExistsException(email);
}

// Kreiranje korisnika
User user = new User(email, password);
return userRepository.save(user);

} catch (InvalidEmailException | InvalidPasswordException e) {
// Validacijske greÅ¡ke
logger.warn("Validacija neuspjeÅ¡na: {}", e.getMessage());
throw new ValidationException(e.getMessage(), e);

} catch (UserAlreadyExistsException e) {
// Poslovni problem
logger.info("PokuÅ¡aj duple registracije: {}", email);
throw e;

} catch (DataAccessException e) {
// TehniÄki problem
logger.error("DB greÅ¡ka pri kreiranju korisnika", e);
throw new ServiceException("Nije moguÄ‡e kreirati korisnika", e);
}
}
}

ğŸ¯ ZakljuÄak

Å to smo nauÄili:

âœ… Try-catch-finally za obradu iznimaka
ğŸ­ Multi-catch i try-with-resources
ğŸŒ³ Hijerarhiju iznimaka (Exception vs Error)
ğŸ·ï¸ Razliku izmeÄ‘u checked i unchecked
ğŸ¾ Kako bacati i deklarirati iznimke
ğŸ¨ Kreiranje vlastitih iznimaka
ğŸ†• Moderne Java 21+ feature-e

Exception handling je umjetnost! VjeÅ¾bom Ä‡ete razviti intuiciju kada i kako koristiti iznimke.
Stack Trace - kako Äitati stazu greÅ¡ke
Logging s LogBackom - profesionalno zapisivanje
Maven - upravljanje ovisnostima
PraktiÄni primjer - igra pogaÄ‘anja brojeva
Quiz - pitanja s Java certifikata

ğŸ’¡ Pro tip: Iznimke nisu greÅ¡ke - one su naÄin komunikacije!

ğŸ” Stack Trace - Tvoj najbolji prijatelj
Stack trace je kao mapa koja te vodi do problema! ğŸ—ºï¸

try {
int rezultat = 10 / 0; // Ups! ğŸ’¥
} catch (ArithmeticException ex) {
ex.printStackTrace(); // IspiÅ¡i trag
String poruka = ex.getMessage(); // "/ by zero"
}

Output:
java.lang.ArithmeticException: / by zero

ğŸ“ Logging - ZaÅ¡to ne samo println?

âŒ System.out.println

Nestaje nakon restarta
Nema razine vaÅ¾nosti
TeÅ¡ko za analizu
Ne radi u produkciji

âœ… LogBack

Trajno spremanje
5 razina (ERROR, WARN...)
Lako za pretraÅ¾ivanje
Profesionalni standard

âš™ï¸ LogBack Konfiguracija
Jedna XML datoteka = svemoÄ‡no logiranje! âœ¨

<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<appender name="FILE" class="ch.qos.logback.core.FileAppender">
<file>logs/app.log</file>
<encoder>
<pattern>%date %level [%thread] %msg%n</pattern>
</encoder>
</appender>

<root level="debug">
<appender-ref ref="FILE" />
</root>
</configuration>

ğŸ“Š Razine Logiranja

ğŸ”´ ERROR - NeÅ¡to je puklo! KritiÄna greÅ¡ka

ğŸŸ  WARN - Oprez! Potencijalni problem

ğŸ”µ INFO - Bitne informacije o radu aplikacije

ğŸŸ¢ DEBUG - Detalji za debugging

âšª TRACE - Sve, baÅ¡ sve!

ğŸ’» LogBack u Akciji

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MojaKlasa {
private static final Logger logger =
LoggerFactory.getLogger(MojaKlasa.class);

public void radNesto() {
try {
// Tvoj kod
logger.info("ZapoÄeo rad! ğŸš€");
} catch (Exception ex) {
logger.error("DoÅ¡lo je do greÅ¡ke!", ex);
}
}
}

ğŸ”§ Apache Maven
Zaboravi ruÄno dodavanje JAR datoteka! ğŸ¯

Prije Mavena ğŸ˜¢

RuÄno preuzimanje JARova
Konflikti verzija
Kaos u projektu
Problemi pri dijeljenju

S Mavenom ğŸ˜

Automatsko preuzimanje
RjeÅ¡avanje ovisnosti
ÄŒist projekt
Jednostavno dijeljenje

ğŸ“¦ pom.xml - Srce Maven projekta

<project>
<groupId>hr.java.vjezbe</groupId>
<artifactId>iznimke-app</artifactId>
<version>1.0-SNAPSHOT</version>

<dependencies>
<dependency>
<groupId>ch.qos.logback</groupId>
<artifactId>logback-classic</artifactId>
<version>1.5.20</version>
</dependency>
</dependencies>
</project>

ğŸŒ Maven Central Repository
Tvoja biblioteka na dohvat ruke: mvnrepository.com

Kako dodati ovisnost? 3 koraka:

Posjeti mvnrepository.com
PretraÅ¾i biblioteku (npr. "logback")
Kopiraj XML i zalijepi u pom.xml

ğŸ“ IntelliJ automatski preuzima ovisnosti nakon spremanja pom.xml!

ğŸ® PraktiÄni Primjer: Igra PogaÄ‘anja
Napravi vlastite iznimke za igru! ğŸ²

public class PremaliBrojException extends Exception {
public PremaliBrojException(String poruka) {
super(poruka);
}
}

public class PrevelikiBrojException extends Exception {
public PrevelikiBrojException(String poruka) {
super(poruka);
}
}

ğŸ¯ Glavna Logika

public static void provjera(int broj)
throws PremaliBrojException, PrevelikiBrojException {

if (broj < generiraniBroj) {
throw new PremaliBrojException(
"ğŸ”½ Premali broj! PokuÅ¡aj veÄ‡i!"
);
}
else if (broj > generiraniBroj) {
throw new PrevelikiBrojException(
"ğŸ”¼ Preveliki broj! PokuÅ¡aj manji!"
);
}
// Ako smo ovdje - pogodak! ğŸ‰
}

ğŸª Rukovanje Iznimkama

do {
System.out.println("Unesite broj:");
uneseniBroj = scanner.nextInt();
logger.info("Unesen: " + uneseniBroj);

try {
provjera(uneseniBroj);
pogodio = true; // Pogodak! ğŸ¯

} catch (PremaliBrojException ex) {
logger.warn(ex.getMessage(), ex);
System.out.println(ex.getMessage());

} catch (PrevelikiBrojException ex) {
logger.warn(ex.getMessage(), ex);
System.out.println(ex.getMessage());
}
} while(!pogodio);

ğŸ†• Å to je novo u Java 25?

ğŸ¨ PoboljÅ¡ani Pattern Matching

try {
// kod
} catch (Exception ex) when (ex.getMessage().contains("timeout")) {
// SpecifiÄno rukovanje timeout greÅ¡kama
}

ğŸ’¡ Conditional catch blokovi - filtriranje iznimaka direktno u catch!

âœ¨ Best Practices

âœ… Radi

SpecifiÄne iznimke
Jasne poruke
Logiraj sve vaÅ¾no
Zatvori resurse

âŒ Ne radi

catch (Exception e)
Prazni catch blokovi
Ignoriraj iznimke
Pretjerano bacanje

ğŸ§  Vrijeme za Quiz!

Testirajmo znanje s pravim pitanjima
s Java certifikata! ğŸ“

ğŸ’ª Priprema za Oracle Certified Professional!

â“ Pitanje 1
Koja klasa ima najmanje podklasa?
A) Exception ima manje podklasa od RuntimeException i Error
B) RuntimeException ima manje podklasa od Exception i Error
C) Error ima manje podklasa od Exception i RuntimeException âœ“

ObjaÅ¡njenje: Error klasa predstavlja ozbiljne sistemske greÅ¡ke i ima relativno mali broj specifiÄnih podklasa (OutOfMemoryError, StackOverflowError...).

â“ Pitanje 2

String typeOfDog = "Mini Australian Shepherd";
typeOfDog = null;
System.out.println(typeOfDog.length());

Å to Ä‡e se dogoditi?
A) NullPointerException âœ“
B) RuntimeException
C) GreÅ¡ka pri kompajliranju

â“ Pitanje 3
Koje su nove znaÄajke Java 7 za rukovanje iznimkama?
A) multi-catch âœ“
B) boomerang
C) try-with-resources âœ“
D) try-with-riches

Java 7: Multi-catch omoguÄ‡ava hvatanje viÅ¡e iznimaka u jednom bloku!
catch (IOException | SQLException ex)
