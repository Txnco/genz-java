Datoteke u Javi - TehniÄko veleuÄiliÅ¡te u Zagrebu
SadrÅ¾aj

ğŸ“š Uvod u rad s datotekama
ğŸŒŠ Vrste tokova podataka u Javi
ğŸ“ Klasa java.io.File
ğŸ—‚ï¸ SuÄelja i klase iz paketa java.nio.file
âœï¸ Klasa Formatter
ğŸ”„ Tokovi za Äitanje i zapisivanje podataka
ğŸ“Š Klase koje predstavljaju tokove podataka
ğŸ’¾ ÄŒitanje i zapisivanje u binarne datoteke
ğŸ›¡ï¸ Blok "try-with-resources"
âš¡ UnapreÄ‘enja u Javi 9
ğŸŒŠ KoriÅ¡tenje streamova s datotekama
ğŸ” Serijalizacija i deserijalizacija
ğŸ“„ XML format (JAXB)
ğŸ”— JSON format (JSON-B)

Uvod u rad s datotekama

Datoteke se koriste za trajnije pohranjivanje podataka ili dohvat informacija iz njih koje su postojale i prije pokretanja programa
Postoje dvije vrste datoteka: tekstualne i binarne
Iz perspektive Java programa svaka datoteka moÅ¾e se razmatrati kao niz bajtova (engl. stream of bytes)
Svaka datoteka na kraju ima "end-of-file" oznaku kojom se detektira kraj datoteke nakon Äega je potrebno zaustaviti proces Äitanja njenog sadrÅ¾aja
U datoteke je moguÄ‡e spremati i cijele objekte postupkom koji se naziva serijalizacija, a Äitanje podataka o objektima se naziva deserijalizacija

ğŸ’¡ Zanimljivost za Z generaciju
SliÄno kao Å¡to Instagram sprema vaÅ¡e storije ili TikTok Äuva vaÅ¡e draftove - datoteke omoguÄ‡uju programima da "zapamte" stvari i nakon Å¡to ih ugasite!

Vrste tokova podataka u Javi

Tokovi podataka pomoÄ‡u kojih se dohvaÄ‡aju i zapisuju podaci u datoteke mogu biti temeljeni na:

Binarni format

Ulazni i izlazni tok predstavljeni bajtovima
char ima 2 bajta, int 4 bajta, double 8 bajtova itd.
Koristi se kod binarnih datoteka

Znakovni format

Ulazni i izlazni tok predstavljen nizom znakova
Svaki znak ima 2 bajta
Koristi se kod tekstualnih datoteka

Prilikom otvaranja datoteka potrebno je kreirati pripadajuÄ‡i objekt Äiji konstruktor komunicira s operacijskim sustavom
U Javi postoje tri standardna toka podataka:

System.in - za uÄitavanje podataka s tipkovnice
System.out - za ispis podataka na zaslon
System.err - za ispis podataka o pogreÅ¡kama na zaslon

Klasa java.io.File

Predstavlja element datoteÄnog sustava (moÅ¾e biti datoteka ili mapa)
SadrÅ¾i putanju, ime i veliÄinu datoteke, ali ne i sam sadrÅ¾aj
MoÅ¾e kreirati datoteku na sljedeÄ‡e naÄine:

// Kreiranje File objekata
File wf1 = new File("moj.htm");
File wf2 = new File("java\\html\\IO.html");
File wf3 = new File("D:\\java\\25.txt");

// Provjera postojanja i tipa
if (wf1.exists()) {
System.out.println("Datoteka postoji!");
}

if (wf1.isFile()) {
System.out.println("To je datoteka");
} else if (wf1.isDirectory()) {
System.out.println("To je mapa");
}

// Dohvat informacija
System.out.println("Naziv: " + wf1.getName());
System.out.println("Putanja: " + wf1.getPath());
System.out.println("VeliÄina: " + wf1.length() + " bajtova");

SadrÅ¾i niz korisnih metoda: exists(), isFile(), isDirectory(), getName(), getPath() itd.

SuÄelja i klase iz paketa java.nio.file

OmoguÄ‡avaju dohvat podataka iz datoteka pomoÄ‡u sljedeÄ‡ih suÄelja i klasa (uvedeni od Jave SE 6):

SuÄelje/Klasa
Opis

Path (suÄelje)
Objekti predstavljaju lokaciju datoteka ili mape, ali ne omoguÄ‡avaju Äitanje sadrÅ¾aja

Paths (klasa)
SadrÅ¾i statiÄke metode za dohvat Path objekata koji predstavljaju datoteku ili mapu

Files (klasa)
SadrÅ¾i statiÄke metode za rad s datotekama: kopiranje, kreiranje, brisanje, Äitanje sadrÅ¾aja itd.

DirectoryStream (suÄelje)
OmoguÄ‡ava iteraciju kroz sadrÅ¾aj mape

ğŸ¯ Moderna praksa
NIO.2 API (java.nio.file) je moderniji i preporuÄeniji naÄin rada s datotekama u odnosu na stari java.io.File!

Klasa Formatter

SluÅ¾i za oblikovanje teksta koji se moÅ¾e zapisivati u datoteku
Radi po principu koriÅ¡tenja metode printf

import java.util.Formatter;
import java.io.IOException;

public class FormatterPrimjer {
public static void main(String[] args) {
try (Formatter output = new Formatter("clients.txt")) {
// Zapisivanje formatiranih podataka
output.format("%d %s %s %.2f%n",
1, "Ivan", "Horvat", 1500.50);
output.format("%d %s %s %.2f%n",
2, "Ana", "KovaÄ", 2300.75);
output.format("%d %s %s %.2f%n",
3, "Marko", "BabiÄ‡", 1850.00);

System.out.println("Podaci uspjeÅ¡no zapisani!");

} catch (IOException | SecurityException e) {
System.err.println("PogreÅ¡ka: " + e.getMessage());
}
}
}

U sluÄaju nedostatka prava za koriÅ¡tenje datoteke baca se iznimka SecurityException

Tokovi za Äitanje i zapisivanje podataka

U Javi postoji nekoliko klasa koje predstavljaju tokove za razmjenu podataka s datotekama:

ğŸ“¥ Ulazni tokovi podataka
Za Äitanje podataka iz datoteka

ğŸ“¤ Izlazni tokovi podataka
Za zapisivanje podataka u datoteke

Osnovne apstraktne klase za binarne datoteke:

java.io.InputStream - Å¡alje bajtove iz vanjskog izvora u Java program
java.io.OutputStream - Å¡alje bajtove iz Java programa u neko vanjsko odrediÅ¡te

Osnovne apstraktne klase za tekstualne datoteke:

java.io.Reader - prima znakove iz vanjskog izvora i Å¡alje ih u Java program
java.io.Writer - Å¡alje znakove iz Java programa u vanjski izvor

Klase koje predstavljaju tokove podataka

Postoji niz klasa koje predstavljaju implementaciju apstraktnih klasa za Äitanje i zapisivanje tokova podataka u Javi:

Tip
Klase
Namjena

InputStream
FileInputStream, BufferedInputStream, DataInputStream
ÄŒitanje binarnih podataka

OutputStream
FileOutputStream, BufferedOutputStream, DataOutputStream
Zapisivanje binarnih podataka

Reader
FileReader, BufferedReader, InputStreamReader
ÄŒitanje tekstualnih podataka

Writer
FileWriter, BufferedWriter, PrintWriter
Zapisivanje tekstualnih podataka

âš¡ Performance tip
Uvijek koristite Buffered verzije klasa (BufferedReader, BufferedWriter) za bolje performanse pri radu s veÄ‡im datotekama!

ÄŒitanje i zapisivanje u binarne datoteke

Osnovna metoda klase InputStream

public abstract int read() throws IOException

ÄŒita 1 bajt iz ulaznog toka
VraÄ‡a cjelobrojnu vrijednost tog bajta
Metoda read() blokira izvoÄ‘enje ostatka programa dok se bajt ne proÄita

Osnovna metoda klase OutputStream

public abstract void write(int b) throws IOException

Å alje 1 bajt podataka preko izlaznog toka
OdrediÅ¡te taj znak interpretira na odreÄ‘eni naÄin

// Primjer kopiranja datoteke bajt po bajt
try (FileInputStream fis = new FileInputStream("ulaz.bin");
FileOutputStream fos = new FileOutputStream("izlaz.bin")) {

int bajt;
while ((bajt = fis.read()) != -1) {
fos.write(bajt);
}
} catch (IOException e) {
e.printStackTrace();
}

Blok "try-with-resources"

Svaku datoteku je nakon koriÅ¡tenja potrebno zatvoriti pozivom metode close()
Od Jave 7 uveden je poseban "try" blok koji automatski poziva metodu close()
Naziva se "try-with-resources"

import java.io.FileInputStream;
import java.io.IOException;

public class TryWithResourcesPrimjer {
private static final String FILENAME = "test.txt";

public static void main(String[] args) {
// Objekt se automatski zatvara na kraju try bloka
try (FileInputStream fis = new FileInputStream(FILENAME)) {

for (int n = fis.read(); n != -1; n = fis.read()) {
System.out.write(n);
}
System.out.flush();

} catch (IOException ex) {
System.err.println("PogreÅ¡ka kod Äitanja datoteke " + FILENAME);
ex.printStackTrace();
}
// Nije potrebno ruÄno zvati fis.close()!
}
}

âœ¨ Prednosti try-with-resources
Automatsko zatvaranje resursa, ÄiÅ¡Ä‡i kod, manje Å¡anse za memory leakove!

UnapreÄ‘enja bloka "try-with-resources" u Javi 9

U Javi 9 je moguÄ‡e koristiti blok "try-with-resources" na naÄin da se objekti mogu definirati prije bloka i samo se koristiti u njemu:

Uvjet: objekti moraju biti "final" ili "effectively final"

import java.io.FileInputStream;
import java.io.IOException;

public class Java9TryWithResources {
private static final String FILENAME = "test.txt";

public static void main(String[] args) {
// Objekt se kreira PRIJE try bloka
FileInputStream fis = new FileInputStream(FILENAME);

// Objekt se samo koristi u try bloku (mora biti effectively final)
try (fis) {

for (int n = fis.read(); n != -1; n = fis.read()) {
System.out.write(n);
}
System.out.flush();

} catch (IOException ex) {
System.err.println("PogreÅ¡ka kod Äitanja datoteke " + FILENAME);
ex.printStackTrace();
}
// fis se automatski zatvara!
}
}

ğŸ¯ Effectively final
Varijabla je "effectively final" ako joj se vrijednost ne mijenja nakon inicijalizacije, Äak i ako nije eksplicitno oznaÄena kao final.

KoriÅ¡tenje streamova u radu s datotekama

Klasa Files sadrÅ¾i nekoliko metoda koje su vezane uz streamove i drastiÄno olakÅ¡avaju rad s datotekama:

Metoda
Opis

lines(Path putanja)
DohvaÄ‡a sve linije unutar datoteke

list(Path putanja)
DohvaÄ‡a sve datoteke na zadanoj putanji

newDirectoryStream(Path)
Otvara mapu i omoguÄ‡ava dohvaÄ‡anje sadrÅ¾aja

walk(Path putanja)
Otvara mape i sve podmape u hijerarhiji

readString(Path)
ÄŒita cijeli sadrÅ¾aj datoteke u jedan String

writeString(Path, String)
Zapisuje cijeli String u datoteku

import java.nio.file.*;
import java.io.IOException;

// ÄŒitanje svih linija i filtriranje
Files.lines(Paths.get("podaci.txt"))
.filter(line -> line.contains("Java"))
.forEach(System.out::println);

// Ispis svih .java datoteka u mapi
Files.list(Paths.get("./src"))
.filter(path -> path.toString().endsWith(".java"))
.forEach(System.out::println);

Nakon dohvaÄ‡anja podataka, moguÄ‡e je koristiti metode temeljene na lambda izrazima kao Å¡to su filter, forEach, limit, map itd.

Serijalizacija i deserijalizacija u Javi

Tijekom izvoÄ‘enja Java programa objekti koji se koriste su u memoriji
Nakon zavrÅ¡etka programa se oslobaÄ‘a memorija koju su objekti koristili
Ako je potrebno "saÄuvati" objekte kako bi se mogli koristiti i nakon zavrÅ¡etka programa ili ih je potrebno pretvoriti u "fiziÄki" oblik koji se moÅ¾e koristiti za slanje na druge lokacije, potrebno ih je serijalizirati

ğŸ“¦ Serijalizacija
Zapisivanje stanja objekta (vrijednosti varijabli) u binarnom obliku u datoteku

ğŸ“‚ Deserijalizacija
Obrnuti proces Äitanja objekata u binarnom obliku i njihovo "aktiviranje" u trenutno aktivnom programu

âš ï¸ VaÅ¾no
Klase Äiji objekti se Å¾ele serijalizirati moraju implementirati suÄelje Serializable

import java.io.Serializable;

public class Osoba implements Serializable {
private static final long serialVersionUID = 1L;

private String ime;
private String prezime;
private int godina;

// Konstruktori, getteri, setteri...
}

Serijalizacija objekata u Javi

Za serijaliziranje objekata u binarnom obliku koristi se klasa ObjectOutputStream i metoda writeObject():

import java.io.*;
import java.util.Date;

public class SerijalizacijaPrimjer {
public static void main(String[] args) {
try (ObjectOutputStream out = new ObjectOutputStream(
new FileOutputStream("osobe.dat"))) {

// Kreiranje objekata
Zupanija zagrebacka = new Zupanija(
"ZagrebaÄka",
309696,
3078.0,
Zupanija.POZIVNI_BROJ_ZUPANIJA_ZAGREBACKA_GRAD_ZAGREB
);

Osoba osoba = new Osoba(
"Pero",
"PeriÄ‡",
zagrebacka,
new Date()
);

// Serijalizacija objekta
out.writeObject(osoba);

System.out.println("Objekt uspjeÅ¡no serijaliziran!");

} catch (IOException e) {
System.err.println("PogreÅ¡ka prilikom serijalizacije: " + e.getMessage());
e.printStackTrace();
}
}
}

ğŸ’¡ Savjet
MoÅ¾ete serijalizirati viÅ¡e objekata u istu datoteku pozivajuÄ‡i writeObject() viÅ¡e puta.

Deserijalizacija objekata u Javi

Proces deserijalizacije obavlja se istim redoslijedom kojim su objekti i serijalizirani:

import java.io.*;

public class DeserijalizacijaPrimjer {
private static final String SERIALIZATION_FILE_NAME = "osobe.dat";

public static void main(String[] args) {
try (ObjectInputStream in = new ObjectInputStream(
new FileInputStream(SERIALIZATION_FILE_NAME))) {

// Deserijalizacija objekta
Osoba procitanaOsoba = (Osoba) in.readObject();

// Ispis podataka o proÄitanom objektu
System.out.println("Podaci o proÄitanom objektu:");
System.out.println("Ime osobe: " + procitanaOsoba.getIme());
System.out.println("Prezime osobe: " + procitanaOsoba.getPrezime());
System.out.println("Å½upanija: " +
procitanaOsoba.getZupanija().getNaziv());
System.out.println("Datum roÄ‘enja: " +
procitanaOsoba.getDatumRodenja());

} catch (IOException ex) {
System.err.println("PogreÅ¡ka kod Äitanja datoteke: " + ex);
} catch (ClassNotFoundException ex) {
System.err.println("Klasa nije pronaÄ‘ena: " + ex);
}
}
}

âš ï¸ VaÅ¾no
Potrebno je hvatati dvije iznimke: IOException i ClassNotFoundException

Zapisivanje i Äitanje objekata u XML formatu

XML (eXtensible Markup Language) je fleksibilan naÄin strukturiranja podataka u Äitljivom formatu.

ğŸ“‹ Prednosti XML-a:

ÄŒitljiv i razumljiv format za ljude
Platform-independent (ne ovisi o platformi)
Å iroko podrÅ¾an u razliÄitim programskim jezicima
Pogodan za konfiguracije i razmjenu podataka izmeÄ‘u sistema

ğŸ”§ Java XML API-ji:

JAXB (do Java 10)

Java Architecture for XML Binding
Automatsko mapiranje izmeÄ‘u Java objekata i XML-a
Od Java 11 je eksterena biblioteka

Jakarta XML Binding (Java 11+)

Nasljednik JAXB-a
Dio Jakarta EE
PreporuÄen za moderne aplikacije

ğŸ’¡ Zanimljivost
XML se koristi u mnogim poznatim tehnologijama: Android manifesti, Maven pom.xml, Spring konfiguracije, RSS feedovi itd.

XML Serijalizacija s Jakarta XML Binding

1ï¸âƒ£ Dodavanje dependency-ja (Maven):

<dependency>
<groupId>jakarta.xml.bind</groupId>
<artifactId>jakarta.xml.bind-api</artifactId>
<version>4.0.0</version>
</dependency>
<dependency>
<groupId>org.glassfish.jaxb</groupId>
<artifactId>jaxb-runtime</artifactId>
<version>4.0.2</version>
</dependency>

2ï¸âƒ£ OznaÄavanje klase s anotacijama:

import jakarta.xml.bind.annotation.*;

@XmlRootElement(name = "student")
@XmlAccessorType(XmlAccessType.FIELD)
public class Student {

@XmlElement(name = "id")
private int id;

@XmlElement(name = "ime")
private String ime;

@XmlElement(name = "prezime")
private String prezime;

@XmlElement(name = "prosjek")
private double prosjek;

// Prazan konstruktor je obavezan za JAXB
public Student() {}

public Student(int id, String ime, String prezime, double prosjek) {
this.id = id;
this.ime = ime;
this.prezime = prezime;
this.prosjek = prosjek;
}

// Getteri i setteri...
}

Zapisivanje objekata u XML datoteku

import jakarta.xml.bind.*;
import java.io.File;

public class XMLSerijalizacija {
public static void main(String[] args) {
try {
// Kreiranje objekta studenta
Student student = new Student(
1,
"Ana",
"Horvat",
4.8
);

// Kreiranje JAXB konteksta
JAXBContext context = JAXBContext.newInstance(Student.class);

// Kreiranje marshallera (za zapisivanje u XML)
Marshaller marshaller = context.createMarshaller();

// Postavljanje formatiranja (za ljepÅ¡i ispis)
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.setProperty(Marshaller.JAXB_ENCODING, "UTF-8");

// Zapisivanje u datoteku
File xmlFile = new File("student.xml");
marshaller.marshal(student, xmlFile);

// Ispis na ekran za provjeru
marshaller.marshal(student, System.out);

System.out.println("\nStudent uspjeÅ¡no zapisan u XML!");

} catch (JAXBException e) {
System.err.println("PogreÅ¡ka kod XML serijalizacije: "
+ e.getMessage());
e.printStackTrace();
}
}
}

ğŸ“„ Rezultat - student.xml:

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student>
<id>1</id>
<ime>Ana</ime>
<prezime>Horvat</prezime>
<prosjek>4.8</prosjek>
</student>

ÄŒitanje objekata iz XML datoteke

import jakarta.xml.bind.*;
import java.io.File;

public class XMLDeserijalizacija {
public static void main(String[] args) {
try {
// Kreiranje JAXB konteksta
JAXBContext context = JAXBContext.newInstance(Student.class);

// Kreiranje unmarshallera (za Äitanje iz XML-a)
Unmarshaller unmarshaller = context.createUnmarshaller();

// ÄŒitanje objekta iz datoteke
File xmlFile = new File("student.xml");
Student student = (Student) unmarshaller.unmarshal(xmlFile);

// Ispis uÄitanih podataka
System.out.println("Podaci o proÄitanom studentu:");
System.out.println("ID: " + student.getId());
System.out.println("Ime: " + student.getIme());
System.out.println("Prezime: " + student.getPrezime());
System.out.println("Prosjek: " + student.getProsjek());

} catch (JAXBException e) {
System.err.println("PogreÅ¡ka kod XML deserijalizacije: "
+ e.getMessage());
e.printStackTrace();
}
}
}

ğŸ¯ PraktiÄna primjena
XML se Äesto koristi za:

Konfiguracijske datoteke aplikacija
Razmjenu podataka izmeÄ‘u razliÄitih sistema
Web servise (SOAP)
Export/import podataka

Zapisivanje i Äitanje objekata u JSON formatu

JSON (JavaScript Object Notation) je lagan, Äitljiv format za razmjenu podataka koji je postao standard u modernom razvoju softvera.

ğŸš€ Prednosti JSON-a:

Jednostavniji i komaktniji od XML-a
Native format za JavaScript i web aplikacije
BrÅ¾a obrada i manja veliÄina datoteka
Dominantan format u REST API-jima
OdliÄan za moderne microservice arhitekture

ğŸ”§ Java JSON biblioteke:

Jakarta JSON Binding (JSON-B)

SluÅ¾beni Java EE/Jakarta EE standard
SliÄan JAXB-u, ali za JSON
Jednostavan za koriÅ¡tenje

Jackson

Najpopularnija JSON biblioteka
Visoke performanse
Bogat feature set

ğŸ’¡ Zanimljivost za Z generaciju
Svaki put kad koristite Instagram, TikTok, Spotify ili bilo koju drugu mobilnu app - Å¡aljete i primate podatke u JSON formatu! ğŸ“±

JSON-B Serijalizacija - Setup

1ï¸âƒ£ Dodavanje dependency-ja (Maven):

<dependency>
<groupId>jakarta.json.bind</groupId>
<artifactId>jakarta.json.bind-api</artifactId>
<version>3.0.0</version>
</dependency>
<dependency>
<groupId>org.eclipse</groupId>
<artifactId>yasson</artifactId>
<version>3.0.3</version>
<scope>runtime</scope>
</dependency>

2ï¸âƒ£ Kreiranje klase (nije potrebno oznaÄavanje anotacijama!):

public class Korisnik {
private int id;
private String korisnickoIme;
private String email;
private boolean aktivan;

// Prazan konstruktor
public Korisnik() {}

public Korisnik(int id, String korisnickoIme,
String email, boolean aktivan) {
this.id = id;
this.korisnickoIme = korisnickoIme;
this.email = email;
this.aktivan = aktivan;
}

// Getteri i setteri za sve varijable
public int getId() { return id; }
public void setId(int id) { this.id = id; }

public String getKorisnickoIme() { return korisnickoIme; }
public void setKorisnickoIme(String korisnickoIme) {
this.korisnickoIme = korisnickoIme;
}

// ... ostali getteri i setteri
}

Zapisivanje objekata u JSON datoteku

import jakarta.json.bind.*;
import java.io.*;
import java.util.*;

public class JSONSerijalizacija {
public static void main(String[] args) {
try {
// Kreiranje Jsonb instance
Jsonb jsonb = JsonbBuilder.create();

// Kreiranje jednog korisnika
Korisnik korisnik = new Korisnik(
1,
"ana.horvat",
"[emailÂ protected]",
true
);

// Zapisivanje objekta u JSON string
String json = jsonb.toJson(korisnik);
System.out.println("JSON reprezentacija:\n" + json);

// Zapisivanje u datoteku
try (FileWriter writer = new FileWriter("korisnik.json")) {
writer.write(json);
}

// MoÅ¾emo raditi i s listama objekata!
List<Korisnik> korisnici = Arrays.asList(
new Korisnik(1, "ana.horvat", "[emailÂ protected]", true),
new Korisnik(2, "marko.markic", "[emailÂ protected]", true),
new Korisnik(3, "ivana.ivic", "[emailÂ protected]", false)
);

String jsonLista = jsonb.toJson(korisnici);
try (FileWriter writer = new FileWriter("korisnici.json")) {
writer.write(jsonLista);
}

System.out.println("\nâœ… Podaci uspjeÅ¡no zapisani u JSON!");

} catch (Exception e) {
System.err.println("PogreÅ¡ka: " + e.getMessage());
e.printStackTrace();
}
}
}

ğŸ“„ Rezultat - korisnik.json:

{
"id": 1,
"korisnickoIme": "ana.horvat",
"email": "[emailÂ protected]",
"aktivan": true
}

ÄŒitanje objekata iz JSON datoteke

import jakarta.json.bind.*;
import java.io.*;
import java.nio.file.*;
import java.util.*;

public class JSONDeserijalizacija {
public static void main(String[] args) {
try {
// Kreiranje Jsonb instance
Jsonb jsonb = JsonbBuilder.create();

// ÄŒitanje JSON-a iz datoteke
String json = Files.readString(Paths.get("korisnik.json"));

// Deserijalizacija u objekt
Korisnik korisnik = jsonb.fromJson(json, Korisnik.class);

// Ispis podataka
System.out.println("ProÄitani podaci o korisniku:");
System.out.println("ID: " + korisnik.getId());
System.out.println("KorisniÄko ime: " + korisnik.getKorisnickoIme());
System.out.println("Email: " + korisnik.getEmail());
System.out.println("Aktivan: " + korisnik.isAktivan());

// ÄŒitanje liste objekata
String jsonLista = Files.readString(Paths.get("korisnici.json"));

// Deserijalizacija liste - koristimo Type reference
List<Korisnik> korisnici = jsonb.fromJson(
jsonLista,
new ArrayList<Korisnik>(){}.getClass().getGenericSuperclass()
);

System.out.println("\nLista korisnika:");
for (Korisnik k : korisnici) {
System.out.printf("- %s (%s) - %s%n",
k.getKorisnickoIme(),
k.getEmail(),
k.isAktivan() ? "Aktivan" : "Neaktivan"
);
}

} catch (Exception e) {
System.err.println("PogreÅ¡ka: " + e.getMessage());
e.printStackTrace();
}
}
}

JSON-B - Napredne moguÄ‡nosti

ğŸ¨ Prilagodba formatiranja:

import jakarta.json.bind.*;

// Konfiguracija za lijep ispis
JsonbConfig config = new JsonbConfig()
.withFormatting(true)  // Formatiran ispis s novim redovima
.withNullValues(true)  // UkljuÄi null vrijednosti
.withEncoding("UTF-8"); // Postavi encoding

Jsonb jsonb = JsonbBuilder.create(config);

ğŸ·ï¸ Prilagodba imena polja s anotacijama:

import jakarta.json.bind.annotation.*;
import java.time.LocalDate;

public class Proizvod {
@JsonbProperty("product_id")
private int id;

@JsonbProperty("product_name")
private String naziv;

@JsonbDateFormat("dd.MM.yyyy")
private LocalDate datumKreiranja;

@JsonbTransient  // Ovo polje se neÄ‡e serijalizirati
private String interniKod;

// Konstruktori, getteri, setteri...
}

ğŸ”¥ Real-world primjer
Kad razvijate REST API ili radite s bazom podataka preko JPA, JSON-B automatski radi serijalizaciju/deserijalizaciju izmeÄ‘u HTTP zahtjeva i Java objekata!

Usporedba: Binary vs XML vs JSON

Karakteristika
Binary (Serializable)
XML
JSON

ÄŒitljivost
âŒ Nije Äitljiv ljudima
âœ… ÄŒitljiv
âœ… Vrlo Äitljiv

VeliÄina datoteke
âœ… Najmanja
âŒ NajveÄ‡a
âœ… Mala do srednja

Brzina
âœ… NajbrÅ¾a
âŒ Sporija
âœ… Brza

Interoperabilnost
âŒ Samo Java
âœ… Svi jezici
âœ… Svi jezici

Validacija schema
âŒ Nema
âœ… XSD
âœ… JSON Schema

Web API
âŒ Ne koristi se
âš ï¸ SOAP (legacy)
âœ… REST (standard)

ğŸ“Š Kada koristiti koji format?

âœ… Koristi Binary serijalizaciju

Interni Java sustavi
Cache mehanizmi
Performanse su kritiÄne

âœ… Koristi XML

Konfiguracijske datoteke
Legacy sistemi
Potrebna je validacija schema

âœ… Koristi JSON (najpopularniji izbor!)

REST API-ji
Web aplikacije
Mobile aplikacije
Microservices
NoSQL baze (MongoDB)
Config datoteke (moderne)

PraktiÄni primjer: REST API s JSON-om

Primjer kako se JSON koristi u stvarnoj web aplikaciji s Spring Boot-om:

import org.springframework.web.bind.annotation.*;
import java.util.*;

@RestController
@RequestMapping("/api/korisnici")
public class KorisnikController {

private List<Korisnik> korisnici = new ArrayList<>();

// GET zahtjev - vraÄ‡a JSON
@GetMapping
public List<Korisnik> dohvatiSveKorisnike() {
return korisnici;  // Automatski se pretvara u JSON!
}

// GET zahtjev s parametrom - vraÄ‡a jedan objekt kao JSON
@GetMapping("/{id}")
public Korisnik dohvatiKorisnika(@PathVariable int id) {
return korisnici.stream()
.filter(k -> k.getId() == id)
.findFirst()
.orElse(null);
}

// POST zahtjev - prima JSON i kreira objekt
@PostMapping
public Korisnik kreirajKorisnika(@RequestBody Korisnik korisnik) {
korisnici.add(korisnik);
return korisnik;  // VraÄ‡a JSON natrag klijentu
}

// PUT zahtjev - aÅ¾urira postojeÄ‡i objekt
@PutMapping("/{id}")
public Korisnik azurirajKorisnika(@PathVariable int id,
@RequestBody Korisnik noviPodaci) {
Korisnik postojeci = korisnici.stream()
.filter(k -> k.getId() == id)
.findFirst()
.orElse(null);

if (postojeci != null) {
postojeci.setKorisnickoIme(noviPodaci.getKorisnickoIme());
postojeci.setEmail(noviPodaci.getEmail());
postojeci.setAktivan(noviPodaci.isAktivan());
}
return postojeci;
}
}

ğŸ’¡ Å to se dogaÄ‘a u pozadini?
Spring Boot automatski koristi Jackson biblioteku za konverziju izmeÄ‘u JSON-a i Java objekata. Programer ne mora ruÄno pozivati JsonbBuilder!

Best Practices za rad s datotekama

1ï¸âƒ£ Uvijek koristi try-with-resources
Automatski zatvara resurse i sprjeÄava memory leakove

2ï¸âƒ£ Koristi NIO.2 API (java.nio.file)
Moderniji, brÅ¾i i fleksibilniji od starog java.io

3ï¸âƒ£ Koristi buffering za velike datoteke
BufferedReader/Writer drastiÄno poboljÅ¡avaju performanse

4ï¸âƒ£ Hvtaj specifiÄne iznimke
IOException, FileNotFoundException, itd.

5ï¸âƒ£ JSON > XML za nove projekte
Jednostavniji, brÅ¾i, bolji za web i mobile

6ï¸âƒ£ Postavi encoding eksplicitno
Koristi UTF-8 za compatibility

7ï¸âƒ£ Validiraj putanje datoteka
Provjeri da datoteka postoji prije Äitanja

8ï¸âƒ£ Ne Äitaj cijelu veliku datoteku u memoriju
Koristi streamove za procesiranje liniju po liniju

9ï¸âƒ£ Koristi Files utility metode
Files.lines(), Files.readString(), Files.writeString()

ğŸ”Ÿ Dokumentiraj format datoteka
Jasno napiÅ¡i Å¡to tvoj program oÄekuje

ğŸ’ª PraktiÄna vjeÅ¾ba

Zadatak: Sustav za upravljanje studentima

Kreirajte Java aplikaciju koja:

Definira klasu Student s poljima: id, ime, prezime, JMBAG, prosjek, godina studija
OmoguÄ‡ava kreiranje liste studenata
Sprema listu studenata u JSON datoteku
ÄŒita studente iz JSON datoteke
Filtrira studente s prosjekom iznad 4.0
Sortira studente po prezimenu
Ispisuje rezultate na ekran


Datoteke u Javi - Auditorne vjeÅ¾be - TVZ
SadrÅ¾aj

ğŸ“ Primjer rada s datotekama i mapama
âœï¸ Zapisivanje s Formatter klasom
ğŸ“– ÄŒitanje binarne datoteke
ğŸ“‹ Kopiranje binarne datoteke
ğŸ“„ ÄŒitanje tekstualne datoteke
ğŸŒŠ KoriÅ¡tenje streamova s datotekama
ğŸ” Serijalizacija i deserijalizacija
ğŸ“„ XML serijalizacija (JAXB)
ğŸ”— JSON serijalizacija (JSON-B)
ğŸ“ Pitanja s certifikata

Primjer rada s datotekama i mapama

VjeÅ¾ba 1
Provjera postojanja datoteke ili mape koristeÄ‡i Path i Files klase:

import java.nio.file.*;
import java.util.Scanner;

Scanner input = new Scanner(System.in);

System.out.println("Unesite naziv datoteke ili mape:");

Path path = Paths.get(input.nextLine());

if (Files.exists(path)) {
// navedena datoteka ili mapa postoji
System.out.println("Datoteka ili mapa postoji!");
} else {
System.out.printf("%s ne postoji!%n", path);
}

ğŸ’¡ ObjaÅ¡njenje

Paths.get() - pretvara string u Path objekt
Files.exists() - provjerava postoji li datoteka ili mapa
Path - predstavlja lokaciju u datoteÄnom sustavu

Primjer rada s datotekama i mapama

VjeÅ¾ba 1 - nastavak
DohvaÄ‡anje informacija o datoteci ili mapi:

System.out.printf("%n%s postoji%n", path.getFileName());
System.out.printf("%s mapa %n",
Files.isDirectory(path) ? "je" : "nije");
System.out.printf("%s apsolutna putanja %n",
path.isAbsolute() ? "je" : "nije");
System.out.printf("Posljednja promjena: %s%n",
Files.getLastModifiedTime(path));
System.out.printf("VeliÄina: %s%n", Files.size(path));
System.out.printf("Putanja: %s%n", path);
System.out.printf("Apsolutna putanja: %s%n", path.toAbsolutePath());

if (Files.isDirectory(path)) {
System.out.printf("%nSadrÅ¾aj mape:%n");

DirectoryStream directoryStream =
Files.newDirectoryStream(path);

for (Path p : directoryStream) {
System.out.println(p);
}
}

ObjaÅ¡njenje koriÅ¡tenih metoda

Paths.get() - pomoÄ‡u statiÄke metode pretvara se putanja datoteke ili mape u objekt Path
Files.exists() - provjerava postoji li datoteka na odreÄ‘enoj putanji
getFileName() - sluÅ¾i za dohvaÄ‡anje naziva datoteke ili mape
isDirectory() - odreÄ‘uje je li rijeÄ o mapi ili datoteci
isAbsolute() - provjerava radi li se o apsolutnoj ili relativnoj putanji
toAbsolutePath() - pretvara putanju u apsolutnu putanju
getLastModifiedTime() - dohvaÄ‡a vrijeme posljednje promjene u datoteci
size() - dohvaÄ‡a veliÄinu datoteke
DirectoryStream - omoguÄ‡ava dohvaÄ‡anje sadrÅ¾aja mape

Zapisivanje u datoteku - Formatter klasa

VjeÅ¾ba 2
Osnovna struktura programa za zapisivanje u datoteku:

import java.util.Formatter;
import java.util.Scanner;

public class FormatterExample {
private static Formatter output;

public static void main(String[] args) {
openFile();
addRecords();
closeFile();
}

public static void closeFile() {
if (output != null) {
output.close();
}
}

// openFile() i addRecords() na sljedeÄ‡em slajdu...
}

ğŸ”‘ VaÅ¾no
Uvijek zatvorite Formatter nakon koriÅ¡tenja kako biste osigurali da su svi podaci zapisani u datoteku!

Otvaranje datoteke - openFile()

VjeÅ¾ba 2 - nastavak

public static void openFile() {
try {
output = new Formatter("clients.txt");
}
catch (SecurityException securityException) {
System.err.println("Write permission denied. Terminating.");
System.exit(1);
}
catch (FileNotFoundException fileNotFoundException) {
System.err.println("Error opening file. Terminating.");
System.exit(1);
}
}

âš ï¸ Iznimke

SecurityException - nema prava za pisanje
FileNotFoundException - problem s otvaranjem datoteke

Dodavanje zapisa - addRecords()

VjeÅ¾ba 2 - nastavak

public static void addRecords() {
Scanner input = new Scanner(System.in);
System.out.printf("%s%n%s%n? ",
"Enter account number, first name, last name and balance.",
"Enter end-of-file indicator to end input.");

while (input.hasNext()) {
try {
output.format("%d %s %s %.2f%n",
input.nextInt(),
input.next(),
input.next(),
input.nextDouble());
}
catch (FormatterClosedException formatterClosedException) {
System.err.println("Error writing to file. Terminating.");
break;
}
catch (NoSuchElementException elementException) {
System.err.println("Invalid input. Please try again.");
input.nextLine();
}

System.out.print("? ");
}
}

ÄŒitanje binarne datoteke

VjeÅ¾ba 3
ÄŒitanje datoteke bajt po bajt koristeÄ‡i FileInputStream:

import java.io.*;

public static final String FILENAME = "datumi.dat";
public static final int DATE_FORMAT_LENGTH = "dd.MM.yyyy.".length();

public static void main(String[] args) {
try {
InputStream in = new FileInputStream(FILENAME);
char[] data = new char[DATE_FORMAT_LENGTH];

for (int i = 0; i < data.length; i++) {
int datum = in.read();
if (datum == -1) {
break;
}
data[i] = (char) datum;
}

System.out.println("ProÄitani datum : " + String.valueOf(data));
in.close();
} catch (IOException ex) {
System.err.println(ex.getMessage());
}
}

ğŸ’¡ Napomena
Metoda read() vraÄ‡a -1 kada doÄ‘e do kraja datoteke (EOF).

Kopiranje binarne datoteke

VjeÅ¾ba 4
UÄinkovito kopiranje binarne datoteke koristeÄ‡i buffer:

import java.io.*;

public static final String IN_BIN_FILE_NAME = "binary_digits.dat";
public static final String OUT_BIN_FILE_NAME = "binary_digits_copy.dat";

File inFile = new File(IN_BIN_FILE_NAME);
File outFile = new File(OUT_BIN_FILE_NAME);

try (FileInputStream fin = new FileInputStream(inFile);
FileOutputStream fout = new FileOutputStream(outFile)) {

byte[] buffer = new byte[1024];

while (true) {
int bytesRead = fin.read(buffer);
if (bytesRead == -1) {
break;
}
fout.write(buffer, 0, bytesRead);
}
} catch(IOException ex) {
System.err.println(ex.getMessage());
}

âš¡ Performance tip
KoriÅ¡tenje buffera od 1024 bajta znaÄajno ubrzava kopiranje velikih datoteka!

Kopiranje datoteke s Files klasom

VjeÅ¾ba 4 - alternativa
Moderni naÄin kopiranja datoteka koristeÄ‡i NIO.2 API:

import java.io.*;
import java.nio.file.Files;

public static void copyFile(File from, File to) throws IOException {
Files.copy(from.toPath(), to.toPath());
}

ğŸ¯ Preporuka
Ovo je preporuÄeni naÄin za kopiranje datoteka u modernom Javi - jednostavniji i sigurniji!

// Primjer koriÅ¡tenja
File izvor = new File("original.txt");
File destinacija = new File("kopija.txt");

try {
copyFile(izvor, destinacija);
System.out.println("Datoteka uspjeÅ¡no kopirana!");
} catch (IOException e) {
System.err.println("GreÅ¡ka pri kopiranju: " + e.getMessage());
}

ÄŒitanje tekstualne datoteke

VjeÅ¾ba 5
ÄŒitanje tekstualne datoteke liniju po liniju:

import java.io.*;

public static final String FILE_NAME = "input.txt";

try (BufferedReader in = new BufferedReader(
new FileReader(FILE_NAME))) {

String line;
while ((line = in.readLine()) != null) {
System.out.println(line);
}

} catch (IOException e) {
System.err.println(e);
}

âœ¨ Prednosti BufferedReader

UÄinkovito Äitanje velikih datoteka
Metoda readLine() Äita cijelu liniju
Automatsko buffering poveÄ‡ava performanse

ÄŒitanje tekstualne datoteke u Javi 11+

VjeÅ¾ba 5 - moderniji naÄin
Najjednostavniji naÄin Äitanja cijele datoteke u String:

import java.nio.file.*;
import java.io.IOException;

Path datoteka = Path.of("datoteka.txt");

try {
String tekst = Files.readString(datoteka);
System.out.println("ProÄitana datoteka:");
System.out.println(tekst);
} catch (IOException e) {
e.printStackTrace();
}

ğŸš€ Java 11+ novost
Metoda Files.readString() uvedena je u Javi 11 i omoguÄ‡ava Äitanje cijele datoteke u jedan String poziv!

âš ï¸ Upozorenje
Koristi se samo za manje datoteke jer uÄitava cijelu datoteku u memoriju odjednom!

Zapisivanje u tekstualne datoteke

VjeÅ¾ba 6
Zapisivanje teksta u datoteku koristeÄ‡i PrintWriter:

import java.io.*;

public static final String FILE_NAME = "output.txt";

public static void main(String[] args) {
try (PrintWriter out = new PrintWriter(
new FileWriter(new File(FILE_NAME)))) {

int i = 0;
do {
out.println((i + 1) + ". redak");
i++;
} while (i < 10);

} catch (IOException e) {
System.err.println(e);
}
}

ğŸ’¡ PrintWriter prednosti

Jednostavne metode za ispis: print(), println(), printf()
Automatsko formatiranje podataka
Ne baca checked iznimke pri pisanju

Zapisivanje u tekstualne datoteke u Javi 11+

VjeÅ¾ba 6 - moderniji naÄin
Najjednostavniji naÄin zapisivanja String-a u datoteku:

import java.nio.file.*;
import java.io.IOException;

String tekst = "Ovo je tekst koji se zapisuje u datoteku!\nDrugi redak teksta";

Path datoteka = Path.of("datoteka.txt");

try {
Files.writeString(datoteka, tekst);
System.out.println("Tekst uspjeÅ¡no zapisan!");
} catch (IOException e) {
e.printStackTrace();
}

ğŸš€ Java 11+ novost
Metoda Files.writeString() omoguÄ‡ava zapisivanje String-a u datoteku jednim pozivom!

// Dodavanje teksta na kraj postojeÄ‡e datoteke
Files.writeString(datoteka, "\nNovi tekst",
StandardOpenOption.APPEND);

KoriÅ¡tenje streamova s datotekama

VjeÅ¾ba 7
ÄŒitanje datoteke koristeÄ‡i Stream API:

import java.nio.file.*;
import java.io.IOException;
import java.util.*;
import java.util.stream.*;

List listaStringova;

try (Stream stream =
Files.lines(new File("dat/radneMemorije.txt").toPath())) {

listaStringova = stream.collect(Collectors.toList());

} catch (IOException e) {
e.printStackTrace();
logger.error("DoÅ¡lo je do pogreÅ¡ke u Äitanju datoteke!", e);
}

âš ï¸ VaÅ¾no
Obvezno koristiti "try-with-resources" kako bi se datoteka automatski zatvorila nakon zavrÅ¡etka operacije Äitanja!

Streamovi - list() i walk()

VjeÅ¾ba 7 - nastavak

Files.list() - samo trenutna mapa

Files.list(new File(".").toPath())
.filter(p -> !p.getFileName()
.toString().startsWith("."))
.limit(3)
.forEach(System.out::println);

Files.walk() - rekurzivno kroz sve podmape

Files.walk(new File(".").toPath())
.filter(p -> !p.getFileName()
.toString().startsWith("."))
.forEach(System.out::println);

ğŸ” Razlika

list() - prikazuje samo sadrÅ¾aj trenutne mape
walk() - prolazi rekurzivno kroz sve podmape

Serijalizacija objekata

VjeÅ¾ba 8
Zapisivanje objekta u binarnu datoteku:

import java.io.*;
import java.util.Date;

public static final String SERIALIZATION_FILE_NAME = "osobe.dat";

try (ObjectOutputStream out = new ObjectOutputStream(
new FileOutputStream(SERIALIZATION_FILE_NAME))) {

Osoba osoba = new Osoba(
"Pero",
"PeriÄ‡",
Zupanija.ZUPANIJA_ZAGREBACKA,
new Date()
);

out.writeObject(osoba);
System.out.println("Objekt uspjeÅ¡no serijaliziran!");

} catch (IOException ex) {
System.err.println(ex);
}

âš ï¸ Preduvjet
Klasa Osoba mora implementirati suÄelje Serializable!

Deserijalizacija objekata

VjeÅ¾ba 8 - nastavak
ÄŒitanje objekta iz binarne datoteke:

try (ObjectInputStream in = new ObjectInputStream(
new FileInputStream(SerijalizacijaTest.SERIALIZATION_FILE_NAME))) {

Osoba procitanaOsoba = (Osoba) in.readObject();

System.out.println("Podaci o proÄitanom objektu:");
System.out.println("Ime osobe: " + procitanaOsoba.getIme());
System.out.println("Prezime osobe: " + procitanaOsoba.getPrezime());
System.out.println("Datum roÄ‘enja osobe: " +
procitanaOsoba.getDatumRodjenja());
System.out.println("Å½upanija: " +
procitanaOsoba.getZupanija().getNaziv());

} catch (IOException ex) {
System.err.println(ex);
} catch (ClassNotFoundException ex) {
System.err.println(ex);
}

âš ï¸ Iznimke
Potrebno je hvatati dvije iznimke: IOException i ClassNotFoundException

XML serijalizacija - Setup

VjeÅ¾ba 9 - XML

1. Dodavanje dependency-ja (Maven)

<dependency>
<groupId>jakarta.xml.bind</groupId>
<artifactId>jakarta.xml.bind-api</artifactId>
<version>4.0.0</version>
</dependency>
<dependency>
<groupId>org.glassfish.jaxb</groupId>
<artifactId>jaxb-runtime</artifactId>
<version>4.0.2</version>
</dependency>

2. Kreiranje klase Student

import jakarta.xml.bind.annotation.*;

@XmlRootElement(name = "student")
@XmlAccessorType(XmlAccessType.FIELD)
public class Student {

@XmlElement private int id;
@XmlElement private String ime;
@XmlElement private String prezime;
@XmlElement private double prosjek;

public Student() {} // Obavezan prazan konstruktor!

public Student(int id, String ime, String prezime, double prosjek) {
this.id = id;
this.ime = ime;
this.prezime = prezime;
this.prosjek = prosjek;
}

// Getteri i setteri...
}

Zapisivanje objekta u XML datoteku

VjeÅ¾ba 9 - nastavak

import jakarta.xml.bind.*;
import java.io.File;

public class XMLSerijalizacijaVjezba {

public static void main(String[] args) {
try {
// Kreiranje studenta
Student student = new Student(1, "Ana", "Horvat", 4.8);

// Kreiranje JAXB konteksta
JAXBContext context = JAXBContext.newInstance(Student.class);

// Kreiranje marshallera (za zapisivanje)
Marshaller marshaller = context.createMarshaller();

// Postavljanje formatiranja
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
marshaller.setProperty(Marshaller.JAXB_ENCODING, "UTF-8");

// Zapisivanje u datoteku
File xmlFile = new File("student.xml");
marshaller.marshal(student, xmlFile);

System.out.println("âœ… Student uspjeÅ¡no zapisan u XML!");

// Ispis na ekran
marshaller.marshal(student, System.out);

} catch (JAXBException e) {
System.err.println("GreÅ¡ka: " + e.getMessage());
}
}
}

ÄŒitanje objekta iz XML datoteke

VjeÅ¾ba 9 - nastavak

import jakarta.xml.bind.*;
import java.io.File;

public class XMLDeserijalizacijaVjezba {

public static void main(String[] args) {
try {
// Kreiranje JAXB konteksta
JAXBContext context = JAXBContext.newInstance(Student.class);

// Kreiranje unmarshallera (za Äitanje)
Unmarshaller unmarshaller = context.createUnmarshaller();

// ÄŒitanje objekta iz datoteke
File xmlFile = new File("student.xml");
Student student = (Student) unmarshaller.unmarshal(xmlFile);

// Ispis uÄitanih podataka
System.out.println("Podaci proÄitanog studenta:");
System.out.println("ID: " + student.getId());
System.out.println("Ime: " + student.getIme());
System.out.println("Prezime: " + student.getPrezime());
System.out.println("Prosjek: " + student.getProsjek());

} catch (JAXBException e) {
System.err.println("GreÅ¡ka: " + e.getMessage());
}
}
}

ğŸ“„ Rezultat - student.xml

<?xml version="1.0" encoding="UTF-8"?>
<student>
<id>1</id>
<ime>Ana</ime>
<prezime>Horvat</prezime>
<prosjek>4.8</prosjek>
</student>

XML - Lista objekata

VjeÅ¾ba 9 - dodatak

Wrapper klasa za listu

import jakarta.xml.bind.annotation.*;
import java.util.List;

@XmlRootElement(name = "studenti")
@XmlAccessorType(XmlAccessType.FIELD)
public class StudentiLista {

@XmlElement(name = "student")
private List<Student> studenti;

public StudentiLista() {}

public StudentiLista(List<Student> studenti) {
this.studenti = studenti;
}

public List<Student> getStudenti() {
return studenti;
}

public void setStudenti(List<Student> studenti) {
this.studenti = studenti;
}
}

Zapisivanje liste u XML

VjeÅ¾ba 9 - dodatak

import java.util.*;

List<Student> lista = Arrays.asList(
new Student(1, "Ana", "Horvat", 4.8),
new Student(2, "Marko", "MarkoviÄ‡", 4.5),
new Student(3, "Ivana", "IviÄ‡", 4.9)
);

StudentiLista studentiLista = new StudentiLista(lista);

JAXBContext context = JAXBContext.newInstance(StudentiLista.class);
Marshaller marshaller = context.createMarshaller();
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);

marshaller.marshal(studentiLista, new File("studenti.xml"));

ğŸ“„ Rezultat - studenti.xml

<studenti>
<student>
<id>1</id>
<ime>Ana</ime>
<prezime>Horvat</prezime>
<prosjek>4.8</prosjek>
</student>
<student>
<id>2</id>
<ime>Marko</ime>
<prezime>MarkoviÄ‡</prezime>
<prosjek>4.5</prosjek>
</student>
</studenti>

JSON serijalizacija - Setup

VjeÅ¾ba 10 - JSON

1. Dodavanje dependency-ja (Maven)

<dependency>
<groupId>jakarta.json.bind</groupId>
<artifactId>jakarta.json.bind-api</artifactId>
<version>3.0.0</version>
</dependency>
<dependency>
<groupId>org.eclipse</groupId>
<artifactId>yasson</artifactId>
<version>3.0.3</version>
<scope>runtime</scope>
</dependency>

2. Kreiranje klase Proizvod

public class Proizvod {
private int id;
private String naziv;
private double cijena;
private boolean naSkladistu;

public Proizvod() {} // Prazan konstruktor

public Proizvod(int id, String naziv, double cijena,
boolean naSkladistu) {
this.id = id;
this.naziv = naziv;
this.cijena = cijena;
this.naSkladistu = naSkladistu;
}

// Getteri i setteri za sva polja...
}

ğŸ’¡ Napomena
Za JSON-B nisu potrebne anotacije kao kod XML-a!

Zapisivanje objekta u JSON datoteku

VjeÅ¾ba 10 - nastavak

import jakarta.json.bind.*;
import java.io.*;

public class JSONSerijalizacijaVjezba {

public static void main(String[] args) {
try {
// Kreiranje Jsonb instance
Jsonb jsonb = JsonbBuilder.create();

// Kreiranje proizvoda
Proizvod proizvod = new Proizvod(
1,
"Laptop Dell XPS 15",
8999.99,
true
);

// Pretvaranje objekta u JSON string
String json = jsonb.toJson(proizvod);

// Ispis na ekran
System.out.println("JSON reprezentacija:");
System.out.println(json);

// Zapisivanje u datoteku
try (FileWriter writer = new FileWriter("proizvod.json")) {
writer.write(json);
}

System.out.println("\nâœ… Proizvod uspjeÅ¡no zapisan u JSON!");

} catch (Exception e) {
System.err.println("GreÅ¡ka: " + e.getMessage());
}
}
}

ÄŒitanje objekta iz JSON datoteke

VjeÅ¾ba 10 - nastavak

import jakarta.json.bind.*;
import java.nio.file.*;
import java.io.IOException;

public class JSONDeserijalizacijaVjezba {

public static void main(String[] args) {
try {
// Kreiranje Jsonb instance
Jsonb jsonb = JsonbBuilder.create();

// ÄŒitanje JSON-a iz datoteke
String json = Files.readString(Paths.get("proizvod.json"));

// Deserijalizacija u objekt
Proizvod proizvod = jsonb.fromJson(json, Proizvod.class);

// Ispis uÄitanih podataka
System.out.println("ProÄitani podaci o proizvodu:");
System.out.println("ID: " + proizvod.getId());
System.out.println("Naziv: " + proizvod.getNaziv());
System.out.println("Cijena: " + proizvod.getCijena() + " EUR");
System.out.println("Na skladiÅ¡tu: " +
(proizvod.isNaSkladistu() ? "DA" : "NE"));

} catch (Exception e) {
System.err.println("GreÅ¡ka: " + e.getMessage());
}
}
}

ğŸ“„ Rezultat - proizvod.json

{
"id": 1,
"naziv": "Laptop Dell XPS 15",
"cijena": 8999.99,
"naSkladistu": true
}

JSON - Lista objekata

VjeÅ¾ba 10 - dodatak

Zapisivanje liste

import java.util.*;

Jsonb jsonb = JsonbBuilder.create();

List<Proizvod> proizvodi = Arrays.asList(
new Proizvod(1, "Laptop Dell XPS 15", 8999.99, true),
new Proizvod(2, "iPhone 15 Pro", 7499.00, true),
new Proizvod(3, "Samsung Galaxy S24", 5999.00, false)
);

// Serijalizacija liste
String jsonLista = jsonb.toJson(proizvodi);

// Zapisivanje u datoteku
Files.writeString(Paths.get("proizvodi.json"), jsonLista);

ÄŒitanje liste

// ÄŒitanje JSON-a
String jsonLista = Files.readString(Paths.get("proizvodi.json"));

// Deserijalizacija liste
List<Proizvod> proizvodi = jsonb.fromJson(
jsonLista,
new ArrayList<Proizvod>(){}.getClass().getGenericSuperclass()
);

// Iteracija kroz listu
System.out.println("Lista proizvoda:");
for (Proizvod p : proizvodi) {
System.out.printf("%d. %s - %.2f EUR%n",
p.getId(), p.getNaziv(), p.getCijena());
}

JSON-B - Napredne moguÄ‡nosti

VjeÅ¾ba 10 - dodatak

Prilagodba formatiranja

import jakarta.json.bind.*;

// Konfiguracija za lijep ispis
JsonbConfig config = new JsonbConfig()
.withFormatting(true)        // Formatirani ispis
.withNullValues(true)        // UkljuÄi null vrijednosti
.withEncoding("UTF-8");      // UTF-8 encoding

Jsonb jsonb = JsonbBuilder.create(config);

Prilagodba imena polja

import jakarta.json.bind.annotation.*;

public class Proizvod {
@JsonbProperty("product_id")
private int id;

@JsonbProperty("product_name")
private String naziv;

@JsonbTransient  // Ovo polje se neÄ‡e serijalizirati
private String interniKod;

@JsonbDateFormat("dd.MM.yyyy")
private LocalDate datumKreiranja;

// Konstruktori, getteri, setteri...
}

Usporedba: Binary vs XML vs JSON

ğŸ“Š PraktiÄna usporedba

Isti objekt Student(1, "Ana", "Horvat", 4.8):

Binary (Serializable):  ~120 bajtova
XML (JAXB):            ~180 bajtova
JSON (JSON-B):         ~80 bajtova

Brzina deserijalizacije (relativno):
Binary: 1.0x (najbrÅ¾e)
JSON:   1.5x
XML:    2.5x (najsporije)

ğŸ¯ Kada koristiti koji format?

Binary - interni Java sistemi, cache, performanse kritiÄne
XML - legacy sustavi, konfiguracijske datoteke, potrebna validacija
JSON - REST API-ji, web/mobile aplikacije, moderna praksa â­

ğŸ’ª PraktiÄni zadatak

Kreirajte sustav za upravljanje knjiÅ¾nicom

ğŸ“š Zahtjevi

Kreirajte klasu Knjiga s poljima: id, naslov, autor, isbn, cijena, godinaIzdanja
Implementirajte spremanje liste knjiga u JSON datoteku
Implementirajte Äitanje knjiga iz JSON datoteke
Dodajte metode za:

Pretragu knjiga po autoru
Filtriranje knjiga po godini izdanja
Sortiranje po cijeni

Dodajte export/import u XML format

ğŸ¯ Bonus

Dodajte izraÄun prosjeÄne cijene svih knjiga
Implementirajte pretragu s viÅ¡e kriterija odjednom
Kreirajte jednostavni konzolni meni za upravljanje

Pitanja s certifikata (1)

ğŸ“ Pitanja s certifikata
Na ovom slajdu u originalnoj prezentaciji nalaze se pitanja s Oracle Java certifikata.
PreporuÄam da ih prouÄite iz sluÅ¾benih izvora!

ğŸ’¡ Preporuka za uÄenje

Oracle Certified Professional: Java SE 11 Developer
Oracle Certified Professional: Java SE 17 Developer
VjeÅ¾bajte sa stvarnim primjerima koda
Analizirajte izlaz programa prije pokretanja

Pitanja s certifikata (2)

ğŸ¯ Teme za pripremu

Razlika izmeÄ‘u FileInputStream i FileReader
Try-with-resources i AutoCloseable suÄelje
Path i Files API (NIO.2)
Serijalizacija i transient keyword
BufferedReader vs Scanner za Äitanje datoteka
Encoding (UTF-8, ISO-8859-1)

Pitanja s certifikata (3)

TipiÄna pitanja na certifikatima:

1. Å to Ä‡e ispisati ovaj kod?

try (FileReader fr = new FileReader("test.txt")) {
System.out.println(fr.read());
}

Odgovor: Ispisuje ASCII vrijednost prvog znaka u datoteci

2. Je li kod ispravan?

Path p = Paths.get("test.txt");
if (Files.exists(p)) {
Files.delete(p);
}

Odgovor: Da, ali moÅ¾e baciti IOException!

Pitanja s certifikata (4)

ÄŒeste zamke:

âŒ GreÅ¡ka 1: Zaboravljeno zatvaranje

FileWriter fw = new FileWriter("test.txt");
fw.write("Hello");
// GREÅ KA: Nije zatvoreno - podaci moÅ¾da neÄ‡e biti zapisani!

âœ… Ispravno: Try-with-resources

try (FileWriter fw = new FileWriter("test.txt")) {
fw.write("Hello");
} // Automatski se zatvara

Pitanja s certifikata (5)

ğŸ” Analiziraj kod

class Data implements Serializable {
private static final long serialVersionUID = 1L;
transient String password = "secret";
String username = "user";
}

// Nakon serijalizacije i deserijalizacije:
Data data = // ... uÄitano iz datoteke
System.out.println(data.password);    // ?
System.out.println(data.username);    // ?

Odgovor:

password Ä‡e biti null (transient se ne serijalizira)
username Ä‡e biti "user"

Pitanja s certifikata (6)

Performance pitanja:

Koji je brÅ¾i za Äitanje velikih datoteka?

// Opcija A
FileReader fr = new FileReader("big.txt");
int c;
while ((c = fr.read()) != -1) { ... }

// Opcija B
BufferedReader br = new BufferedReader(
new FileReader("big.txt"));
String line;
while ((line = br.readLine()) != null) { ... }

Odgovor: B - BufferedReader koristi buffering i Äita blokove podataka, Å¡to je puno brÅ¾e!
