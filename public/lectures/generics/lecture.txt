GeneriÄko programiranje u Javi
Type-Safe kod s Generics ğŸ¯

ğŸ”’ Type Safety â€¢ ğŸ”„ Reusability â€¢ âš¡ Performance


1ï¸âƒ£ Uvod u Generics

Problem bez Generics-a
ZaÅ¡to ih trebamo?

2ï¸âƒ£ GeneriÄke metode

Sintaksa <T>
Type parameters

3ï¸âƒ£ GeneriÄke klase

Kreiranje generiÄkih klasa
Multiple type parameters

4ï¸âƒ£ Bounded Types

Upper bounds (extends)
Lower bounds (super)

5ï¸âƒ£ Wildcards

? wildcard
PECS princip

6ï¸âƒ£ Best Practices

Raw types - ne!
Type erasure

2

ğŸ˜° Problem: Bez Generics-a (pre-Java 5)

Scenario: Lista igraÄa u gaming lobby-ju

âŒ Prije Java 5 - Sve je Object
// Lista moÅ¾e sadrÅ¾avati bilo Å¡to!
List players = new ArrayList();

// Dodajemo igrace
players.add(new Player("xXDragonSlayerXx"));
players.add(new Player("NoobMaster69"));

// Netko sluÄajno doda String umjesto Player objekta!
players.add("Ovo nije Player!");  // ğŸ˜± Kompajler to dozvoli!

// IzvlaÄenje podataka - OPASNO!
for (int i = 0; i < players.size(); i++) {
Player p = (Player) players.get(i);  // âš ï¸ Casting obavezan
System.out.println(p.getUsername());
}

// ğŸ’¥ RUNTIME ERROR: ClassCastException!
// Exception in thread "main" java.lang.ClassCastException:
// java.lang.String cannot be cast to Player

âš ï¸ Problemi bez Generics-a

âŒ GreÅ¡ke u runtime-u - ne u compile-time!
âŒ Potreban casting - repetitivan i opasan kod
âŒ Nema type safety - moÅ¾eÅ¡ staviti bilo Å¡to u listu
âŒ TeÅ¾e Äitljiv kod - nije jasno Å¡to lista sadrÅ¾ava

3

âœ¨ RjeÅ¡enje: Generics!

âŒ BEZ Generics

// Nije type-safe
List players = new ArrayList();
players.add(new Player("Ana"));
players.add("GreÅ¡ka");  // OK ğŸ˜±

// Casting potreban
Player p = (Player) players.get(0);

// Runtime greÅ¡ka!
Player p2 = (Player) players.get(1);
// ğŸ’¥ ClassCastException!

âœ… SA Generics

// Type-safe!
List<Player> players = new ArrayList<>();
players.add(new Player("Ana"));
players.add("GreÅ¡ka");  // âŒ COMPILE ERROR!

// Bez castinga!
Player p = players.get(0);

// Sigurno - nema runtime greÅ¡ki! âœ…
Player p2 = players.get(1);

ğŸ¯ Å to su Generics?

Generics omoguÄ‡avaju da definiraÅ¡ klase i metode s tipovima kao parametrima.
Kompajler onda moÅ¾e provjeriti tipove u compile-time, ne u runtime!

ğŸ Prednosti Generics-a:

âœ… Type safety u compile-time - greÅ¡ke se hvataju odmah
âœ… Elimininacija castinga - Äitljiviji kod
âœ… Reusabilnost koda - jedna klasa/metoda za sve tipove
âœ… Bolja dokumentacija - jasno se vidi Å¡to metoda prima

4

ğŸ”§ GeneriÄke metode

Sintaksa

public <T> void methodName(T param) {
// T moÅ¾e biti bilo koji tip!
}

<T> se naziva type parameter i oznaÄava da metoda koristi generiÄki tip.

Primjer: Ispis array-a - Generic naÄin
// Jedna metoda za sve tipove! ğŸ‰
public static <T> void printArray(T[] array) {
for (T element : array) {
System.out.print(element + " ");
}
System.out.println();
}

// KoriÅ¡tenje - radi za sve tipove!
Integer[] numbers = {1, 2, 3, 4, 5};
printArray(numbers);  // Output: 1 2 3 4 5

String[] names = {"Ana", "Marko", "Ivana"};
printArray(names);  // Output: Ana Marko Ivana

Double[] prices = {19.99, 29.99, 39.99};
printArray(prices);  // Output: 19.99 29.99 39.99

âŒ Bez Generics - Duplicate kod

// Morali bi napisati 3 metode!
public static void printIntArray(Integer[] arr) {
for (Integer n : arr) {
System.out.print(n + " ");
}
}

public static void printStringArray(String[] arr) {
for (String s : arr) {
System.out.print(s + " ");
}
}

public static void printDoubleArray(Double[] arr) {
for (Double d : arr) {
System.out.print(d + " ");
}
}
// ğŸ˜« Copy-paste, teÅ¡ko za odrÅ¾avanje!

âœ… S Generics - DRY princip

// Samo jedna metoda! ğŸ‰
public static <T> void printArray(T[] arr) {
for (T element : arr) {
System.out.print(element + " ");
}
}

// Radi za SVE tipove!
// Integer, String, Double,
// Player, User, Post...
// bilo Å¡to!

5

ğŸ”¤ Konvencije za Type Parameters

Po konvenciji se koriste velika slova za type parameters:

T - Type
OpÄ‡i tip - najÄeÅ¡Ä‡e koriÅ¡teno

public class Box<T> {
private T item;
}

E - Element
Element u kolekciji

public interface List<E> {
void add(E element);
}

K, V - Key, Value
Za Map strukture

public interface Map<K, V> {
V get(K key);
}

N - Number
Za numeriÄke tipove

public class Calculator<N> {
N sum(N a, N b);
}

Instagram primjer - Multiple type parameters
// Metoda koja prima DVA generiÄka tipa
public static <K, V> Map<K, V> createMap(K key, V value) {
Map<K, V> map = new HashMap<>();
map.put(key, value);
return map;
}

// KoriÅ¡tenje:
Map<String, Integer> likes = createMap("post_123", 1500);
Map<String, User> followers = createMap("@ana", new User("Ana"));

ğŸ’¡ Dobra praksa
Uvijek koristi konvencionalna imena (T, E, K, V)
za type parameters - to Ä‡e razumjeti svaki Java developer!

6

ğŸ“¦ GeneriÄke klase

Klasa moÅ¾e imati type parameter koji se koristi kroz cijelu klasu.

Primjer: Box<T> - Generic kontejner
// GeneriÄka klasa koja moÅ¾e drÅ¾ati bilo koji tip
public class Box<T> {
private T content;

public Box(T content) {
this.content = content;
}

public T getContent() {
return content;
}

public void setContent(T content) {
this.content = content;
}
}

// KoriÅ¡tenje:
Box<String> stringBox = new Box<>("Hello Generics!");
String text = stringBox.getContent();  // Bez castinga!

Box<Integer> numberBox = new Box<>(42);
Integer num = numberBox.getContent();  // Type-safe!

Box<User> userBox = new Box<>(new User("Ana"));
User user = userBox.getContent();  // OdliÄno!

Gaming primjer - Inventory sistem
// Generic inventory za bilo koji tip itema
public class Inventory<T> {
private List<T> items;
private int maxSize;

public Inventory(int maxSize) {
this.items = new ArrayList<>();
this.maxSize = maxSize;
}

public boolean addItem(T item) {
if (items.size() < maxSize) {
items.add(item);
return true;
}
return false; // Inventory full!
}

public T getItem(int index) {
return items.get(index);
}

public int getSize() {
return items.size();
}
}

// KoriÅ¡tenje - razliÄiti inventoryi za razliÄite tipove:
Inventory<Weapon> weapons = new Inventory<>(10);
weapons.addItem(new Weapon("Sword", 50));
weapons.addItem(new Weapon("Bow", 30));

Inventory<Potion> potions = new Inventory<>(20);
potions.addItem(new Potion("Health", 25));
potions.addItem(new Potion("Mana", 15));

// Type-safe - ne moÅ¾eÅ¡ staviti Weapon u potions inventory!
// potions.addItem(new Weapon(...)); // âŒ COMPILE ERROR!

7

ğŸ¥ Real-world primjer: Generic Stack

Stack<T> - LIFO struktura podataka
// Generic Stack implementacija
public class Stack<T> {
private List<T> elements;
private int maxSize;

public Stack(int maxSize) {
this.elements = new ArrayList<>();
this.maxSize = maxSize;
}

// Push element na vrh stacka
public void push(T element) {
if (elements.size() >= maxSize) {
throw new RuntimeException("Stack overflow! ğŸ’¥");
}
elements.add(element);
}

// Pop - ukloni i vrati element s vrha
public T pop() {
if (isEmpty()) {
throw new RuntimeException("Stack je prazan!");
}
return elements.remove(elements.size() - 1);
}

// Peek - pogledaj vrh bez uklanjanja
public T peek() {
if (isEmpty()) {
throw new RuntimeException("Stack je prazan!");
}
return elements.get(elements.size() - 1);
}

public boolean isEmpty() {
return elements.isEmpty();
}

public int size() {
return elements.size();
}
}

KoriÅ¡tenje - Browser History primjer
// Stack za browser back button funkcionalnost
Stack<String> browserHistory = new Stack<>(50);

// Korisnik browsea po stranicama
browserHistory.push("google.com");
browserHistory.push("youtube.com");
browserHistory.push("instagram.com");
browserHistory.push("tiktok.com");

System.out.println("Trenutna stranica: " + browserHistory.peek());
// Output: Trenutna stranica: tiktok.com

// Klikni "Back" button
String previous = browserHistory.pop();
System.out.println("VraÄ‡am se s: " + previous);
// Output: VraÄ‡am se s: tiktok.com

System.out.println("Sada sam na: " + browserHistory.peek());
// Output: Sada sam na: instagram.com

ğŸ¯ ZaÅ¡to je ovo odliÄno?
Jedna Stack<T> klasa radi za SVE tipove:
Stack<String>, Stack<Integer>, Stack<User>, Stack<Post>...
Bez Generics-a bi morali pisati zasebnu klasu za svaki tip! ğŸ˜«

8

ğŸ”’ Bounded Type Parameters

Ponekad Å¾eliÅ¡ ograniÄiti koje tipove generic moÅ¾e prihvatiti.
Koristi extends keyword za upper bound!

Sintaksa - extends keyword
// T mora biti Number ili neÅ¡to Å¡to nasljeÄ‘uje Number
public <T extends Number> void someMethod(T number) {
// Sada moÅ¾emo pozvati metode iz Number klase!
double value = number.doubleValue();
}

âŒ Bez bounds - preopÄ‡enito

// T moÅ¾e biti BILO Å TO
public static <T> double sum(List<T> list) {
double total = 0;
for (T item : list) {
// âŒ ERROR: Ne moÅ¾emo
// koristiti doubleValue()
// jer T nije Number!
total += item.doubleValue();
}
return total;
}

âœ… S bounds - specifiÄno

// T mora biti Number ili podklasa
public static <T extends Number>
double sum(List<T> list) {
double total = 0;
for (T item : list) {
// âœ… OK! T extends Number
// pa ima doubleValue()
total += item.doubleValue();
}
return total;
}

E-commerce primjer - Calculator
// Bounded generic klasa za kalkulacije
public class Calculator<T extends Number> {

public double add(T a, T b) {
return a.doubleValue() + b.doubleValue();
}

public double subtract(T a, T b) {
return a.doubleValue() - b.doubleValue();
}

public double multiply(T a, T b) {
return a.doubleValue() * b.doubleValue();
}
}

// KoriÅ¡tenje:
Calculator<Integer> intCalc = new Calculator<>();
double result1 = intCalc.add(5, 10);  // 15.0

Calculator<Double> doubleCalc = new Calculator<>();
double result2 = doubleCalc.multiply(2.5, 4.0);  // 10.0

// âŒ NE radi - String nije Number!
// Calculator<String> stringCalc = new Calculator<>(); // COMPILE ERROR!

9

ğŸ”— Multiple Bounds

Tip moÅ¾e imati viÅ¡e ograniÄenja odjednom!

Sintaksa - & operator
// T mora biti i Number I Comparable
public <T extends Number & Comparable<T>> T max(T a, T b) {
return a.compareTo(b) > 0 ? a : b;
}

Gaming Leaderboard primjer
// Interface za rangiranje igraÄa
interface Rankable {
int getRank();
}

// Klasa mora biti Comparable I implementirati Rankable
public class Leaderboard<T extends Comparable<T> & Rankable> {
private List<T> players;

public Leaderboard() {
this.players = new ArrayList<>();
}

public void addPlayer(T player) {
players.add(player);
// MoÅ¾emo sortirati jer je Comparable
Collections.sort(players);
}

public T getTopPlayer() {
return players.isEmpty() ? null : players.get(0);
}

public void displayRankings() {
for (T player : players) {
// MoÅ¾emo koristiti getRank() jer implementira Rankable
System.out.println("Rank " + player.getRank() + ": " + player);
}
}
}

// Player klasa koja zadovoljava obje uvjete
class Player implements Comparable<Player>, Rankable {
private String username;
private int score;
private int rank;

@Override
public int compareTo(Player other) {
return Integer.compare(other.score, this.score); // ViÅ¡e = bolje
}

@Override
public int getRank() {
return rank;
}
}

âš ï¸ VaÅ¾no pravilo
Ako imaÅ¡ multiple bounds:

âœ… Klasa mora biti prva (ako postoji)
âœ… Interface-i dolaze nakon
Primjer: <T extends Number & Comparable<T> & Serializable>

10

ğŸƒ Wildcards - Zamjenski znakovi

Wildcard ? oznaÄava "nepoznati tip".
Koristi se u situacijama gdje ne znaÅ¡ ili ne brineÅ¡ o konkretnom tipu.

Problem: PreviÅ¡e specifiÄna metoda
// Ova metoda radi SAMO za List<Integer>
public static void printList(List<Integer> list) {
for (Integer i : list) {
System.out.println(i);
}
}

// Problem:
List<Integer> ints = List.of(1, 2, 3);
printList(ints);  // âœ… OK

List<String> strings = List.of("a", "b", "c");
printList(strings);  // âŒ ERROR - ne prima String!

List<Double> doubles = List.of(1.5, 2.5);
printList(doubles);  // âŒ ERROR - ne prima Double!

RjeÅ¡enje: Unbounded wildcard (?)
// ? = bilo koji tip! Univerzalna metoda!
public static void printList(List<?> list) {
for (Object element : list) {
System.out.println(element);
}
}

// Sada radi za SVE tipove! ğŸ‰
List<Integer> ints = List.of(1, 2, 3);
printList(ints);  // âœ… OK

List<String> strings = List.of("a", "b", "c");
printList(strings);  // âœ… OK

List<Double> doubles = List.of(1.5, 2.5);
printList(doubles);  // âœ… OK

List<User> users = getUsers();
printList(users);  // âœ… OK

ğŸ¤” Kada koristiti wildcard?

âœ… Kada metoda samo Äita elemente
âœ… Kada ne ovisi o konkretnom tipu
âœ… Kada Å¾eliÅ¡ maksimalnu fleksibilnost

11

â¬†ï¸ Upper Bounded Wildcards

<? extends Type> = "bilo koji tip koji JE ili NASLJEÄUJE Type"

Spotify primjer - suma duljina pjesama
// Å½elimo sumirati duljine pjesama razliÄitih tipova
public static double sumDurations(List<? extends Number> durations) {
double total = 0;
for (Number duration : durations) {
total += duration.doubleValue();
}
return total;
}

// Radi za SVE Å¡to nasljeÄ‘uje Number!
List<Integer> intDurations = List.of(180, 240, 195);  // sekunde
double total1 = sumDurations(intDurations);  // âœ… OK

List<Double> doubleDurations = List.of(3.5, 4.2, 3.8);  // minute
double total2 = sumDurations(doubleDurations);  // âœ… OK

List<Long> longDurations = List.of(180000L, 240000L);  // milisekunde
double total3 = sumDurations(longDurations);  // âœ… OK

// âŒ NE radi - String nije Number!
// List<String> strings = List.of("3:00", "4:00");
// sumDurations(strings); // COMPILE ERROR!

Gaming primjer - hijerarhija karaktera
// Hijerarhija klasa
class Character {
protected String name;
protected int health;
}

class Warrior extends Character {
private int armor;
}

class Mage extends Character {
private int mana;
}

// Metoda koja prima bilo koji Character ili podklasu
public static void healParty(List<? extends Character> party) {
for (Character member : party) {
member.health = 100;  // Full heal!
System.out.println("Healed " + member.name);
}
}

// KoriÅ¡tenje:
List<Warrior> warriors = getWarriors();
healParty(warriors);  // âœ… Warrior extends Character

List<Mage> mages = getMages();
healParty(mages);  // âœ… Mage extends Character

List<Character> mixed = getMixedParty();
healParty(mixed);  // âœ… Character sam po sebi

ğŸ’¡ Kada koristiti <? extends T>?
Koristi kada Å¾eliÅ¡ ÄŒITATI podatke iz kolekcije,
ali ne i pisati. Think: "Producer extends" ğŸ“¤

12

â¬‡ï¸ Lower Bounded Wildcards

<? super Type> = "bilo koji tip koji JE ili NADKLASA od Type"

Primjer: Dodavanje elemenata u listu
// MoÅ¾emo PISATI Integer u listu Number ili Object
public static void addNumbers(List<? super Integer> list) {
list.add(1);
list.add(2);
list.add(3);
}

// KoriÅ¡tenje:
List<Integer> integers = new ArrayList<>();
addNumbers(integers);  // âœ… OK - Integer

List<Number> numbers = new ArrayList<>();
addNumbers(numbers);  // âœ… OK - Number je super od Integer

List<Object> objects = new ArrayList<>();
addNumbers(objects);  // âœ… OK - Object je super od Integer

// âŒ NE radi - Double nije super od Integer!
// List<Double> doubles = new ArrayList<>();
// addNumbers(doubles); // COMPILE ERROR!

Discord primjer - slanje notifikacija
// Hijerarhija notifikacija
class Notification {
protected String message;
}

class DirectMessage extends Notification {
private String sender;
}

class MentionNotification extends Notification {
private String channel;
}

// MoÅ¾emo PISATI DirectMessage u listu koja prihvaÄ‡a Notification ili super
public static void sendDirectMessages(
List<? super DirectMessage> inbox,
String sender
) {
inbox.add(new DirectMessage(sender, "Hey! ğŸ‘‹"));
inbox.add(new DirectMessage(sender, "What's up?"));
}

// KoriÅ¡tenje:
List<DirectMessage> dmList = new ArrayList<>();
sendDirectMessages(dmList, "@john");  // âœ… OK

List<Notification> allNotifs = new ArrayList<>();
sendDirectMessages(allNotifs, "@jane");  // âœ… OK - moÅ¾e sve notifikacije

List<Object> everything = new ArrayList<>();
sendDirectMessages(everything, "@bob");  // âœ… OK - Object sve prihvaÄ‡a

ğŸ’¡ Kada koristiti <? super T>?
Koristi kada Å¾eliÅ¡ PISATI podatke u kolekciju.
Think: "Consumer super" ğŸ“¥

13

ğŸ¯ PECS Princip

Producer
Extends,
Consumer
Super

Zlatno pravilo za wildcards! âœ¨

ğŸ“¤ Producer Extends
Kada ÄitaÅ¡/dobavljaÅ¡ iz kolekcije:

// ÄŒitanje iz liste
public static void processNumbers(
List<? extends Number> numbers
) {
for (Number n : numbers) {
System.out.println(n.doubleValue());
}
// âœ… ÄŒitanje - OK!
// âŒ Pisanje - NE!
// numbers.add(5); // ERROR
}

ğŸ“¥ Consumer Super
Kada piÅ¡eÅ¡/dodajeÅ¡ u kolekciju:

// Pisanje u listu
public static void addIntegers(
List<? super Integer> list
) {
list.add(1);
list.add(2);
list.add(3);
// âœ… Pisanje - OK!
// âš ï¸ ÄŒitanje - samo Object
Object obj = list.get(0);
}

Real-world primjer: Collections.copy()
// Stvarna deklaracija iz Java Collections API
public static <T> void copy(
List<? super T> dest,     // Consumer (piÅ¡emo u dest)
List<? extends T> src    // Producer (Äitamo iz src)
) {
for (T item : src) {        // ÄŒitanje iz src
dest.add(item);         // Pisanje u dest
}
}

// Primjer koriÅ¡tenja:
List<Integer> source = List.of(1, 2, 3);
List<Number> destination = new ArrayList<>();

Collections.copy(destination, source);
// âœ… Radi jer:
// - destination je List<? super Integer> (Number je super od Integer)
// - source je List<? extends Integer> (Integer extends Integer)

ğŸ’¡ Kako zapamtiti PECS?

ğŸ“¤ Producer (izvor) â†’ ÄitaÅ¡ podatke â†’ extends
ğŸ“¥ Consumer (odrediÅ¡te) â†’ piÅ¡eÅ¡ podatke â†’ super
ğŸ¯ Ako SAMO ÄitaÅ¡ i piÅ¡eÅ¡ â†’ ne koristi wildcards, koristi <T>

14

ğŸ”„ Type Erasure - Brisanje tipova

Java Generics koriste "type erasure" - kompajler briÅ¡e informaciju o
tipovima u runtime-u zbog backward kompatibilnosti s Java verzijama prije 5.

ğŸ“ Source kod (Å¡to piÅ¡eÅ¡)

// Tvoj kod s Generics
List<String> strings = new ArrayList<>();
strings.add("Java");
strings.add("Generics");

String first = strings.get(0);

// Generic metoda
public <T> void process(T item) {
System.out.println(item);
}

âš™ï¸ Bytecode (Å¡to vidi JVM)

// Nakon type erasure
List strings = new ArrayList();
strings.add("Java");
strings.add("Generics");

String first = (String) strings.get(0);  // Casting!

// T se zamjenjuje s Object
public void process(Object item) {
System.out.println(item);
}

Type Erasure s bounded types
// Source kod
public class Calculator<T extends Number> {
private T value;

public double getValue() {
return value.doubleValue();
}
}

// Nakon type erasure - T se zamjenjuje s Number (ne s Object!)
public class Calculator {
private Number value;  // T â†’ Number

public double getValue() {
return value.doubleValue();
}
}

âš ï¸ Posljedice Type Erasure

âŒ Ne moÅ¾eÅ¡ napraviti new T() - tip ne postoji u runtime-u!
âŒ Ne moÅ¾eÅ¡ napraviti new T[] - array ne moÅ¾e biti generiÄki
âŒ Ne moÅ¾eÅ¡ koristiti instanceof T
âŒ StatiÄki Älanovi ne mogu koristiti type parameters

Å to NE radi zbog Type Erasure
public class Box<T> {
// âŒ ERROR - ne moÅ¾eÅ¡ instancirati T
// T item = new T();

// âŒ ERROR - ne moÅ¾eÅ¡ napraviti array od T
// T[] array = new T[10];

// âŒ ERROR - instanceof ne radi s T
// if (obj instanceof T) { ... }

// âŒ ERROR - statiÄki Älanovi ne mogu koristiti T
// private static T staticField;
}

15

âš ï¸ Raw Types - Nemoj koristiti!

Raw type = koriÅ¡tenje generiÄke klase bez type parametara.
Postoji samo zbog backward kompatibilnosti s pre-Java 5 kodom.

âŒ RAW TYPE - Opasno!

// Bez <> - raw type!
List users = new ArrayList();

// MoÅ¾e primiti SVE - nema type safety!
users.add(new User("Ana"));
users.add("Ovo nije User!");  // ğŸ˜± OK u compile-time
users.add(42);  // ğŸ˜± OK u compile-time

// Potreban casting - opasno!
User u = (User) users.get(0);  // âœ… OK
User u2 = (User) users.get(1);  // ğŸ’¥ ClassCastException!

// âš ï¸ Compiler warning:
// "List is a raw type. References to
// generic type List<E> should be parameterized"

âœ… GENERICS - Sigurno!

// S <> - type-safe!
List<User> users = new ArrayList<>();

// Samo User objekti!
users.add(new User("Ana"));  // âœ… OK

// Compile-time errors - odliÄno!
// users.add("String"); // âŒ COMPILE ERROR
// users.add(42); // âŒ COMPILE ERROR

// Bez castinga - sigurno!
User u = users.get(0);  // âœ… Uvijek User
User u2 = users.get(1);  // âœ… Uvijek User

// ğŸ‰ Nema warnings!

TikTok primjer - Raw type problem
// âŒ LoÅ¡e - Raw type
class VideoQueue {
private List videos = new ArrayList();  // Raw type!

public void addVideo(Object video) {
videos.add(video);
}

public Object nextVideo() {
return videos.remove(0);
}
}

VideoQueue queue = new VideoQueue();
queue.addVideo(new Video("funny_cat.mp4"));
queue.addVideo("Not a video!");  // ğŸ˜± PrihvaÄ‡a String!

Video v = (Video) queue.nextVideo();  // OK
Video v2 = (Video) queue.nextVideo();  // ğŸ’¥ RUNTIME ERROR!

// âœ… Dobro - Generics
class VideoQueue<T> {
private List<T> videos = new ArrayList<>();

public void addVideo(T video) {
videos.add(video);
}

public T nextVideo() {
return videos.remove(0);
}
}

VideoQueue<Video> queue = new VideoQueue<>();
queue.addVideo(new Video("funny_cat.mp4"));
// queue.addVideo("Not a video!"); // âŒ COMPILE ERROR!

Video v = queue.nextVideo();  // âœ… Type-safe, bez castinga!

ğŸš« Pravilo: NIKAD nemoj koristiti raw types!
Raw types postoje samo zbog starih verzija Jave (pre-1.5).
Uvijek koristi Generics za type safety!

16

âœ¨ Best Practices za Generics

1ï¸âƒ£ Eliminiraj raw types

// âŒ LoÅ¡e
List list = new ArrayList();

// âœ… Dobro
List<String> list = new ArrayList<>();

2ï¸âƒ£ Koristi diamond operator

// âŒ Redundantno
List<String> l = new ArrayList<String>();

// âœ… KraÄ‡e (Java 7+)
List<String> l = new ArrayList<>();

3ï¸âƒ£ Preferiraj liste nad arrayima

// âŒ Array - ne type-safe
Object[] arr = new String[10];
arr[0] = 1;  // Runtime error!

// âœ… Lista - type-safe
List<String> list = new ArrayList<>();
// list.add(1); // Compile error!

4ï¸âƒ£ Koristi PECS za wildcards

// Producer - extends
void read(List<? extends T> src);

// Consumer - super
void write(List<? super T> dest);

5ï¸âƒ£ Bounded types kad je potrebno

// OgraniÄi na Number
public <T extends Number>
double sum(List<T> list) {
return list.stream()
.mapToDouble(Number::doubleValue)
.sum();
}

6ï¸âƒ£ Ne koristi instanceof s Generics

// âŒ Ne radi - Type erasure
// if (obj instanceof List<String>)

// âœ… Radi - samo raw type
if (obj instanceof List) {
List<?> list = (List<?>) obj;
}

ğŸ’¡ Golden Rules

âœ… Uvijek koristi Generics umjesto raw types
âœ… Koristi wildcards za fleksibilnost
âœ… PECS princip za wildcards
âœ… Bounded types za ograniÄenja
âŒ Ne pokuÅ¡avaj "prevariti" type system

17

ğŸ¯ PraktiÄni projekt: Generic Cache

Zadatak: Cache sistem za web aplikaciju

Kreiraj generiÄki cache koji moÅ¾e spremati bilo koji tip podataka s TTL (Time To Live).

CacheEntry - wrapper za podatke
class CacheEntry<T> {
private final T value;
private final long expiryTime;

public CacheEntry(T value, long ttlMillis) {
this.value = value;
this.expiryTime = System.currentTimeMillis() + ttlMillis;
}

public boolean isExpired() {
return System.currentTimeMillis() > expiryTime;
}

public T getValue() {
return value;
}
}

GenericCache - glavna klasa
public class GenericCache<K, V> {
private final Map<K, CacheEntry<V>> cache;
private final long defaultTtl;

public GenericCache(long defaultTtlMillis) {
this.cache = new ConcurrentHashMap<>();
this.defaultTtl = defaultTtlMillis;
}

// Dodaj u cache
public void put(K key, V value) {
cache.put(key, new CacheEntry<>(value, defaultTtl));
}

// Dodaj s custom TTL
public void put(K key, V value, long ttlMillis) {
cache.put(key, new CacheEntry<>(value, ttlMillis));
}

// Dohvati iz cache-a
public Optional<V> get(K key) {
CacheEntry<V> entry = cache.get(key);

if (entry == null) {
return Optional.empty();
}

if (entry.isExpired()) {
cache.remove(key);  // OÄisti expired entry
return Optional.empty();
}

return Optional.of(entry.getValue());
}

// OÄisti sve expired entries
public void cleanup() {
cache.entrySet()
.removeIf(entry -> entry.getValue().isExpired());
}

public int size() {
return cache.size();
}

public void clear() {
cache.clear();
}
}

KoriÅ¡tenje - Instagram user cache
// Cache za User objekte - 5 minuta TTL
GenericCache<String, User> userCache =
new GenericCache<>(5 * 60 * 1000);

// Spremi korisnika
User ana = new User("@ana", "Ana Horvat");
userCache.put("@ana", ana);

// Dohvati iz cache-a
Optional<User> cached = userCache.get("@ana");
cached.ifPresent(user ->
System.out.println("Loaded from cache: " + user.getName())
);

// Cache za post statistike - 1 minuta TTL
GenericCache<String, PostStats> statsCache =
new GenericCache<>(60 * 1000);

statsCache.put("post_123", new PostStats(1500, 250));

// Cache za session tokene - 30 minuta TTL
GenericCache<String, SessionToken> sessionCache =
new GenericCache<>(30 * 60 * 1000);

18

ğŸ†• Generics u Java 25+

BuduÄ‡nost Generics-a

Project Valhalla i Project Amber donose poboljÅ¡anja u Generics!

1. Primitive Type Specialization (buduÄ‡nost)
// Trenutno - mora boxing
List<Integer> numbers = new ArrayList<>();
numbers.add(5);  // Boxing: int â†’ Integer (overhead!)

// BuduÄ‡nost - direktno primitive
List<int> numbers = new ArrayList<>();  // MoÅ¾da uskoro!
numbers.add(5);  // Bez boxinga, brÅ¾e!

2. Inline Types (Project Valhalla)
// Inline types - value types bez wrappera
inline class Point<T extends Number> {
private final T x;
private final T y;

// BrÅ¾e, manje memorije, bez heap allocation!
}

3. Better type inference
// Trenutno - ponekad treba eksplicitno
List<String> list = Collections.<String>emptyList();

// Java 25+ - joÅ¡ bolji inference
var list = List.of("a", "b", "c");  // List<String> inferred
var map = Map.of("key", 1, "key2", 2);  // Map<String, Integer>

ğŸš€ Å to moÅ¾emo oÄekivati?

âš¡ Primitive Generics - bez boxing overheada
ğŸ“¦ Inline Types - vrijednosti bez heap allocation
ğŸ¯ Bolji type inference - manje verboze koda
ğŸ”§ Reified Generics - pristup tipovima u runtime-u

ğŸ’¡ Stay Updated!
Prati:

Project Valhalla: Value types i specialized generics
Project Amber: Pattern matching s generics
JEPs: Java Enhancement Proposals na openjdk.org

19

ğŸ“ ZakljuÄak

ğŸ“ Å to smo nauÄili?

GeneriÄke metode i klase
Type parameters (T, E, K, V)
Bounded types (extends, super)
Wildcards (?, extends, super)
PECS princip
Type Erasure

ğŸ’ª Key Takeaways

ğŸ”’ Type safety u compile-time
ğŸ“ ÄŒitljiviji kod bez castinga
â™»ï¸ Reusability - jedna klasa za sve
ğŸš« Nikad raw types!
ğŸ¯ PECS za wildcards

ğŸ‰ Generics = Type Safety + Reusability

Jedna generiÄka klasa bolja je od stotinu specifiÄnih! ğŸ’¡

âŒ Bez Generics

Runtime greÅ¡ke
Puno castinga
Duplicate kod
TeÅ¾e za odrÅ¾avanje

âœ… S Generics

Compile-time greÅ¡ke
Bez castinga
DRY princip
Lako za odrÅ¾avanje

ğŸ“š Dodatni resursi

Oracle Java Tutorials: Generics Tutorial
Effective Java (Joshua Bloch): Poglavlja 26-31
Java Language Specification: Chapter 4 & 8

âš¡ GeneriÄko programiranje u Javi
GeneriÄko programiranje omoguÄ‡ava pisanje fleksibilnog i sigurnog koda koji radi s razliÄitim tipovima podataka uz zadrÅ¾avanje sigurnosti tipova u vrijeme kompilacije.

ğŸ“š SadrÅ¾aj prezentacije:

1ï¸âƒ£ Uvod u Generics
Osnovni koncepti i prednosti

2ï¸âƒ£ GeneriÄke metode
Metode s generiÄkim parametrima

3ï¸âƒ£ Parametrizirane klase
Kreiranje vlastitih generiÄkih klasa

4ï¸âƒ£ Zamjenski simboli
Wildcards i bounded types

5ï¸âƒ£ Moderne znaÄajke
Java 17+ novosti

6ï¸âƒ£ Best Practices
Dobre prakse i savjeti

ğŸ“– Å to su Generics?

GeneriÄko programiranje omoguÄ‡ava definiranje klasa, suÄelja i metoda s parametriziranim tipovima podataka.

ğŸ’¡ ZaÅ¡to koristiti Generics?

Sigurnost tipova u vrijeme kompilacije - greÅ¡ke se otkrivaju prije izvoÄ‘enja programa
Eliminacija castinga - viÅ¡e nije potrebno eksplicitno pretvaranje tipova
Ponovno iskoristivost koda - jedna implementacija radi s viÅ¡e tipova
ÄŒitljiviji kod - jasno se vidi s kojim tipovima radimo

ğŸ’¡ Zanimljivost: Generics su uvedeni u Javi 5.0 (2004.), ali njihov razvoj je trajao 5+ godina! Originalni prijedlog je bio puno kompleksniji.

ğŸ”„ Prije i poslije Generics

âŒ Bez Generics (stari naÄin):

List lista = new ArrayList();
lista.add("Tekst");
lista.add(123); // Kompajler dopuÅ¡ta!

String str = (String) lista.get(0); // Potreban casting
String num = (String) lista.get(1); // ClassCastException! ğŸ’¥

âœ… Sa Generics (moderni naÄin):

List<String> lista = new ArrayList<>();
lista.add("Tekst");
lista.add(123); // GreÅ¡ka pri kompilaciji! âœ“

String str = lista.get(0); // Nema potrebe za casting!

ğŸ¯ KljuÄna prednost: GreÅ¡ke se hvataju u vrijeme kompilacije, a ne izvoÄ‘enja!

ğŸ”§ GeneriÄke metode

GeneriÄke metode su metode koje deklariraju vlastite parametre tipa. Mogu biti dio negeneriÄkih klasa!

ğŸ“ Sintaksa:

public static <T> T metodaNaziv(T parametar) {
// Tip parametar T se deklarira prije povratnog tipa
return parametar;
}

âš ï¸ VaÅ¾no: Parametar tipa <T> se deklarira prije povratnog tipa metode!

ğŸ“Š Primjer: PronalaÅ¾enje maksimuma

Klase koje implementiraju suÄelje Comparable mogu meÄ‘usobno usporeÄ‘ivati svoje objekte pomoÄ‡u metode compareTo.

ğŸ¯ Bounded Type Parameter:

public static <T extends Comparable<T>> T maximum(T x, T y, T z) {
T max = x;

if (y.compareTo(max) > 0) {
max = y;
}

if (z.compareTo(max) > 0) {
max = z;
}

return max;
}

ğŸ’¡ ObjaÅ¡njenje: <T extends Comparable<T>> znaÄi da tip T mora implementirati Comparable suÄelje. Ovo se zove bounded type parameter.

ğŸš€ KoriÅ¡tenje generiÄke metode

public static void main(String[] args) {
// Rad s Integer tipom
System.out.printf("Maximum of %d, %d and %d is %d%n%n",
3, 4, 5, maximum(3, 4, 5));

// Rad s Double tipom
System.out.printf("Maximum of %.1f, %.1f and %.1f is %.1f%n%n",
6.6, 8.8, 7.7, maximum(6.6, 8.8, 7.7));

// Rad s String tipom
System.out.printf("Maximum of %s, %s and %s is %s%n",
"pear", "apple", "orange",
maximum("pear", "apple", "orange"));
}

ğŸ“¤ Izlaz programa:

Maximum of 3, 4 and 5 is 5

Maximum of 6.6, 8.8 and 7.7 is 8.8

Maximum of pear, apple and orange is pear

ğŸ†• Java 17+: PoboljÅ¡ano zakljuÄivanje tipova

Moderne verzije Jave imaju poboljÅ¡an mehanizam zakljuÄivanja tipova (type inference).

ğŸ¯ Primjer s var kljuÄnom rijeÄju:

// Java 10+ - lokalna varijabla s var
var lista = new ArrayList<String>();

// Java kompajler automatski zakljuÄuje tip
var rezultat = maximum(10, 20, 30); // Integer
var tekstMax = maximum("a", "b", "c"); // String

// Diamond operator (<>) automatski zakljuÄuje tip
List<Integer> brojevi = new ArrayList<>(); // <> umjesto <Integer>

ğŸ’¡ Savjet: Koristite var kada je tip oÄigledan iz konteksta. Kod postaje kraÄ‡i ali i dalje type-safe!

ğŸ—ï¸ Parametrizirane klase

Parametrizirana klasa je klasa koja ima jedan ili viÅ¡e parametara tipa.

ğŸ“ Osnovni primjer:

public class Kutija<T> {
private T sadrzaj;

public void postavi(T sadrzaj) {
this.sadrzaj = sadrzaj;
}

public T dohvati() {
return sadrzaj;
}
}

ğŸš€ KoriÅ¡tenje:

Kutija<String> kutijaZaTekst = new Kutija<>();
kutijaZaTekst.postavi("Java Generics");

Kutija<Integer> kutijaZaBroj = new Kutija<>();
kutijaZaBroj.postavi(42);

ğŸ“š Primjer: GeneriÄki Stack

ğŸ—ï¸ Konstruktori i varijable:

public class Stack<T> {
private List<T> elements;

public Stack() {
this(10);
}

public Stack(int capacity) {
int initCapacity = capacity > 0 ? capacity : 10;
elements = new ArrayList<T>(initCapacity);
}
}

ğŸ¯ Dizajn: Stack koristi ArrayList interno za pohranu elemenata. GeneriÄki tip T omoguÄ‡ava da Stack radi s bilo kojim tipom podataka.

âš™ï¸ Stack metode

public void push(T pushValue) {
elements.add(pushValue);
}

public T pop() {
if (elements.isEmpty()) {
throw new EmptyStackException("Stack is empty, cannot pop");
}
return elements.remove(elements.size() - 1);
}

public boolean isEmpty() {
return elements.isEmpty();
}

public int size() {
return elements.size();
}
}

ğŸ§ª Testiranje Stack klase

public static void main(String[] args) {
double[] doubleElements = {1.1, 2.2, 3.3, 4.4, 5.5};

Stack<Double> doubleStack = new Stack<>(5);

testPushDouble(doubleStack, doubleElements);
testPopDouble(doubleStack);
}

private static void testPushDouble(Stack<Double> stack, double[] values) {
System.out.printf("%nPushing elements onto doubleStack%n");
for (double value : values) {
System.out.printf("%.1f ", value);
stack.push(value);
}
}

ğŸ“¤ Pop operacija

private static void testPopDouble(Stack<Double> stack) {
try {
System.out.printf("%nPopping elements from doubleStack%n");
double popValue;

while (true) {
popValue = stack.pop();
System.out.printf("%.1f ", popValue);
}
} catch (EmptyStackException emptyStackException) {
System.err.println();
emptyStackException.printStackTrace();
}
}

âš ï¸ Napomena: BeskonaÄna petlja se prekida kada stack postane prazan i baci se EmptyStackException.

ğŸƒ Zamjenski simboli (Wildcards)

Wildcards omoguÄ‡avaju kreiranje fleksibilnijih generiÄkih metoda.

ğŸ¯ Tri vrste wildcards:

Tip
Sintaksa
ZnaÄenje

Unbounded
List<?>
Lista bilo kojeg tipa

Upper bounded
List<? extends Number>
Lista Number ili njegovih podtipova

Lower bounded
List<? super Integer>
Lista Integer ili njegovih nadtipova

ğŸ“ PECS pravilo:
Producer Extends, Consumer Super
Ako ÄitaÅ¡ iz kolekcije â†’ extends
Ako piÅ¡eÅ¡ u kolekciju â†’ super

â¬†ï¸ Upper Bounded Wildcards

ğŸ¯ Primjer: Zbrajanje brojeva

public static double sum(List<? extends Number> list) {
double total = 0;

for (Number element : list) {
total += element.doubleValue();
}

return total;
}

ğŸ’¡ ObjaÅ¡njenje: ? extends Number znaÄi da metoda prihvaÄ‡a listu bilo kojeg tipa koji je Number ili nasljeÄ‘uje Number (Integer, Double, Float, itd.).

ğŸš€ Primjer koriÅ¡tenja

public static void main(String[] args) {
// Lista Integer brojeva
Integer[] integers = {1, 2, 3, 4, 5};
List<Integer> integerList = Arrays.asList(integers);
System.out.printf("integerList: %s%n", integerList);
System.out.printf("Total: %.0f%n%n", sum(integerList));

// Lista Double brojeva
Double[] doubles = {1.1, 3.3, 5.5};
List<Double> doubleList = Arrays.asList(doubles);
System.out.printf("doubleList: %s%n", doubleList);
System.out.printf("Total: %.1f%n%n", sum(doubleList));

// MjeÅ¡ovita lista Number objekata
Number[] numbers = {1, 2.4, 3, 4.1};
List<Number> numberList = Arrays.asList(numbers);
System.out.printf("numberList: %s%n", numberList);
System.out.printf("Total: %.1f%n", sum(numberList));
}

ğŸ†• Java 17+: GeneriÄki Records

Records (uvedeni u Java 16) takoÄ‘er mogu biti generiÄki!

ğŸ“ Primjer: Par vrijednosti

// Jednostavna definicija generiÄkog record-a
public record Par<T, U>(T prvi, U drugi) {
// Automatski generirani konstruktor, getteri, toString, equals, hashCode
}

ğŸš€ KoriÅ¡tenje:

Par<String, Integer> student = new Par<>("Ana", 20);
System.out.println(student.prvi());   // Ana
System.out.println(student.drugi());  // 20

Par<Double, Double> koordinate = new Par<>(45.8, 15.9);
System.out.println(koordinate); // Par[prvi=45.8, drugi=15.9]

ğŸ¯ Prednosti: Records nude kompaktnu sintaksu za immutable data klase. Idealni zaDTO objekte!

ğŸ†• Java 21+: Pattern Matching za Generics

ğŸ¯ Pattern Matching for switch (Preview)

public static String obradi(Object obj) {
return switch (obj) {
case Integer i when i > 0 ->
"Pozitivan broj: " + i;
case Integer i when i < 0 ->
"Negativan broj: " + i;
case String s when s.length() > 0 ->
"Tekst: " + s;
case List<?> list ->
"Lista s " + list.size() + " elemenata";
default -> "Nepoznat tip";
};
}

ğŸ’¡ Novost: Pattern matching omoguÄ‡ava elegantnije rukovanje razliÄitim tipovima bez eksplicitnog castinga!

ğŸ†• Java 21: Sequenced Collections

Java 21 uvodi nova suÄelja za kolekcije s definiranim redoslijedom.

ğŸ“‹ Nova suÄelja:

interface SequencedCollection<E> extends Collection<E> {
SequencedCollection<E> reversed();
void addFirst(E e);
void addLast(E e);
E getFirst();
E getLast();
E removeFirst();
E removeLast();
}

ğŸš€ Primjer:

List<String> lista = new ArrayList<>();
lista.addFirst("prvi");
lista.addLast("zadnji");

String prvi = lista.getFirst();  // "prvi"
String zadnji = lista.getLast(); // "zadnji"

var obrnuto = lista.reversed();   // Obrnuti pogled

âœ¨ Dobre prakse (Best Practices)

âœ… Å to Äiniti:

âœ“ Koristite deskriptivna imena za parametre tipa (npr. T za Type, E za Element, K za Key, V za Value)
âœ“ Preferirajte bounded type parameters kada je moguÄ‡e (<T extends Number>)
âœ“ Koristite wildcards za fleksibilnost u metodama
âœ“ Favorizirajte kompoziciju nad nasljeÄ‘ivanjem generiÄkih klasa
âœ“ Koristite diamond operator <> za kraÄ‡i kod

âŒ Å to izbjegavati:

âœ— Ne koristite raw types (List umjesto List<String>)
âœ— Izbjegavajte unchecked castove
âœ— Ne kreirajte generiÄke nizove (new T[] nije moguÄ‡e)
âœ— Ne koristite primitive tipove kao parametre (List<int> ne radi, koristite List<Integer>)

ğŸ”„ Type Erasure - Brisanje tipova

Type erasure je proces kojim Java kompajler uklanja sve informacije o generiÄkim tipovima tijekom kompilacije.

ğŸ“ Primjer transformacije:

Izvorni kod
Nakon type erasure

List<String> lista
List lista

<T extends Number>
Number

<T>
Object

âš ï¸ Posljedice Type Erasure:

Ne moÅ¾ete kreirati instance generiÄkog tipa: new T() âŒ
Ne moÅ¾ete koristiti instanceof s parametriziranim tipovima
Ne moÅ¾ete kreirati nizove generiÄkih tipova

ğŸ¯ Multiple Type Bounds

Parametar tipa moÅ¾e imati viÅ¡e ograniÄenja (bounds).

ğŸ“ Sintaksa:

public class MultipleGranice<T extends Number & Comparable<T>> {
private T vrijednost;

public MultipleGranice(T vrijednost) {
this.vrijednost = vrijednost;
}

public boolean jeVeceOd(T drugo) {
// MoÅ¾emo koristiti metode i iz Number i iz Comparable
return vrijednost.compareTo(drugo) > 0
&& vrijednost.doubleValue() > 0;
}
}

ğŸ’¡ Pravilo: Klasa (ako postoji) mora biti prva u listi bounds, zatim suÄelja. Koristite & za razdvajanje.

ğŸ’¾ PraktiÄni primjer: GeneriÄki Cache

public class Cache<K, V> {
private final Map<K, V> cache = new HashMap<>();
private final int maxSize;

public Cache(int maxSize) {
this.maxSize = maxSize;
}

public void put(K key, V value) {
if (cache.size() >= maxSize) {
// Ukloni najstariji element
var firstKey = cache.keySet().iterator().next();
cache.remove(firstKey);
}
cache.put(key, value);
}

public Optional<V> get(K key) {
return Optional.ofNullable(cache.get(key));
}
}

ğŸš€ KoriÅ¡tenje:

Cache<String, Integer> rezultati = new Cache<>(100);
rezultati.put("marko", 95);
rezultati.get("marko").ifPresent(System.out::println);

ğŸ“¦ Varargs i Generics

MoÅ¾ete kombinirati generiÄke tipove s varargs parametrima.

// Metoda koja prihvaÄ‡a proizvoljan broj elemenata
public static <T> List<T> listaOd(T... elementi) {
return new ArrayList<>(Arrays.asList(elementi));
}

// KoriÅ¡tenje:
var brojevi = listaOd(1, 2, 3, 4, 5);
var imena = listaOd("Ana", "Marko", "Ivana");

âš ï¸ Heap Pollution: Varargs s generiÄkim tipovima mogu uzrokovati "heap pollution" upozorenja. Koristite @SafeVarargs anotaciju ako ste sigurni da je metoda sigurna.

// SafeVarargs anotacija
@SafeVarargs
public static final <T> List<T> sigurnaListaOd(T... elementi) {
return Arrays.asList(elementi);
}

ğŸ†• Java 25: Unnamed Patterns & Variables

Java 25 donosi nove sintaksne moguÄ‡nosti za rad s pattern matchingom.

ğŸ“ Primjer s unnamed patterns:

// KoriÅ¡tenje underscore (_) za zanemarivanje vrijednosti
public static <T, U> T uzmiPrvi(Par<T, U> par) {
return switch (par) {
case Par(var prvi, _) -> prvi; // _ zanemaruje drugi element
};
}

// TakoÄ‘er moÅ¾emo koristiti _ u lambda izrazima
lista.forEach(_ -> System.out.println("Element"));

ğŸ’¡ Korisno: Underscore _ jasno pokazuje da odreÄ‘enu vrijednost namjerno zanemarujemo.

ğŸ‹ï¸ PraktiÄne vjeÅ¾be

ğŸ“ Zadaci za vjeÅ¾bu:

Zadatak 1: GeneriÄka metoda za zamjenu
NapiÅ¡ite generiÄku metodu swap() koja zamjenjuje dva elementa u polju na zadanim pozicijama.

Zadatak 2: Prioritetni red
Implementirajte generiÄku klasu PriorityQueue<T extends Comparable<T>> koja odrÅ¾ava elemente sortirane.

Zadatak 3: Filtriranje kolekcije
Kreirajte generiÄku metodu filter() koja prima List<T> i Predicate<T>, vraÄ‡a novu listu filtriranih elemenata.

Zadatak 4: GeneriÄki Pair builder
Implementirajte klasu za kreiranje parova vrijednosti s metodama za transformaciju obje vrijednosti.

ğŸ“ Pitanja za ponavljanje

ğŸ¯ Provjerite svoje znanje:

Pitanje 1: Je li moguÄ‡e kreirati niz generiÄkog tipa? ZaÅ¡to da/ne?

Pitanje 2: Koja je razlika izmeÄ‘u <? extends T> i <? super T>?

Pitanje 3: Å to je type erasure i koje su njegove posljedice?

Pitanje 4: MoÅ¾e li generiÄka klasa implementirati viÅ¡e bounded type parametara?

Pitanje 5: ZaÅ¡to ne moÅ¾emo koristiti primitive tipove kao generiÄke parametre?

ğŸ’¡ Savjet: Raspravite odgovore u grupi ili s profesorom. Razumijevanje ovih koncepata je kljuÄno za naprednije teme!

ğŸ“š Dodatni resursi za uÄenje

ğŸŒ Online resursi:

Oracle Java Tutorials - SluÅ¾bena dokumentacija o generiÄkom programiranju
Effective Java (Joshua Bloch) - Poglavlja 26-31 o Generics
Java Language Specification - Detaljna tehniÄka specifikacija
Baeldung - PraktiÄni tutoriali i primjeri

ğŸ“ PreporuÄeni Älanci:

Java Generics FAQs (Angelika Langer)
Generics in Java - Complete Tutorial
Understanding Wildcards in Java
Java 21+ New Features Guide
