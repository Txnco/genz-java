Lambda izrazi u Javi
Å to su lambda izrazi?
ZaÅ¡to ih koristiti?

2ï¸âƒ£ Sintaksa

Osnovna sintaksa
RazliÄiti formati

3ï¸âƒ£ Funkcionalna suÄelja

Predefined suÄelja
Custom suÄelja

4ï¸âƒ£ Method References

Vrste referenci
PraktiÄna primjena

5ï¸âƒ£ Stream API

Filter, Map, Reduce
Collectors

6ï¸âƒ£ Best Practices

ÄŒeste greÅ¡ke
Savjeti i trikovi

2

ğŸ¤” Å to su Lambda izrazi?

Definicija

Lambda izraz je anonimna funkcija koja omoguÄ‡ava pisanje kraÄ‡eg,
Äitljivijeg koda. Uvedeni su u Java 8 i revolucionirali su naÄin programiranja.

ğŸ’­ Razmisli ovako:

ğŸµ Spotify Playlist
Umjesto da ruÄno odabireÅ¡ svaku pjesmu, samo kaÅ¾eÅ¡:
"Pusti sve rock pjesme iz 2023." - Lambda je ta jednostavna naredba!

ğŸ“¸ Instagram Filter
Ne trebaÅ¡ znati kako filter radi iznutra, samo ga primijeÅ¡ na sliku jednim klikom.
Lambda je kao taj filter za kod!

3

ğŸ¯ ZaÅ¡to koristiti Lambda izraze?

âŒ PRIJE (tradicionalni naÄin)

Sortiranje liste - tradicionalno
// TikTok korisnici po broju followera
List<User> users = getTikTokUsers();

Collections.sort(users, new Comparator<User>() {
@Override
public int compare(User u1, User u2) {
return Integer.compare(
u1.getFollowers(),
u2.getFollowers()
);
}
});

// ğŸ˜“ 9 linija koda za jednostavnu operaciju!

âœ… S LAMBDA IZRAZOM

Sortiranje liste - lambda
// TikTok korisnici po broju followera
List<User> users = getTikTokUsers();

users.sort((u1, u2) ->
Integer.compare(u1.getFollowers(), u2.getFollowers())
);

// ğŸ‰ 3 linije - isti rezultat!

// Ili joÅ¡ kraÄ‡e s method reference:
users.sort(Comparator.comparingInt(User::getFollowers));

ğŸ’¡ Pro Tip
Lambda izrazi Äine kod:

ğŸ“ KraÄ‡im - manje koda za pisanje i odrÅ¾avanje
ğŸ‘€ ÄŒitljivijim - fokus na ono Å¡to radiÅ¡, ne kako
ğŸš€ Modernijim - funkcionalni stil programiranja

4

ğŸ“ Sintaksa Lambda izraza

OpÄ‡a sintaksa

(parametri) -> { tijelo lambda izraza }

â†’ Arrow operator povezuje parametre s tijelom funkcije

ğŸ“– RazliÄiti formati lambda izraza:

1. Bez parametara
// Jednostavna lambda bez parametara
() -> System.out.println("Hello from Lambda! ğŸ‘‹");

// Ili s viÅ¡e linija koda
() -> {
System.out.println("Pokretanje Stream aplikacije...");
streamService.start();
return "Streaming started!";
};

2. Jedan parametar
// Zagrade oko parametra su opcijske
name -> System.out.println("Hi " + name);

// Ili s eksplicitnim tipom (opcijski)
(String name) -> System.out.println("Hi " + name);

// YouTube primjer - subscribe notifikacija
channel -> sendNotification("New video on " + channel);

3. ViÅ¡e parametara
// Zagrade su obavezne za viÅ¡e parametara
(x, y) -> x + y;

// Discord primjer - slanje DM poruke
(user, message) -> user.sendDirectMessage(message);

// S eksplicitnim tipovima
(Integer followers, Integer likes) -> followers + likes;

5

ğŸ”Œ Funkcionalna suÄelja (Functional Interfaces)

Funkcionalno suÄelje je suÄelje s toÄno jednom apstraktnom metodom.
Lambda izrazi mogu se koristiti samo s funkcionalnim suÄeljima!

Vlastito funkcionalno suÄelje
// @FunctionalInterface anotacija osigurava da imamo samo jednu metodu
@FunctionalInterface
interface ContentModerator {
boolean isAppropriate(String content);
}

// KoriÅ¡tenje s lambdom
ContentModerator moderator = content ->
!content.contains("spam") &&
!content.contains("inappropriate");

// Provjera sadrÅ¾aja
boolean canPost = moderator.isAppropriate("Check out my new video!");
System.out.println("Can post: " + canPost); // true

âš¡ Quick Fact
Java ima viÅ¡e ugraÄ‘enih funkcionalnih suÄelja u java.util.function paketu.
Ne moraÅ¡ uvijek praviti svoje!

6

ğŸ UgraÄ‘ena funkcionalna suÄelja

Predicate<T>
Prima argument, vraÄ‡a boolean

// Filter za Instagram story
Predicate<Story> isActive =
story -> story.getHoursOld() < 24;

// Provjera
if (isActive.test(myStory)) {
showStory(myStory);
}

Function<T,R>
Prima argument tipa T, vraÄ‡a rezultat tipa R

// Username formatter
Function<String, String> addAtSign =
name -> "@" + name.toLowerCase();

String handle = addAtSign.apply("JohnDoe");
// Result: "@johndoe"

Consumer<T>
Prima argument, ne vraÄ‡a niÅ¡ta

// Slanje push notifikacije
Consumer<User> sendNotif =
user -> notificationService
.send(user.getId(), "New message!");

users.forEach(sendNotif);

Supplier<T>
Ne prima argumente, vraÄ‡a rezultat

// Random quote generator
Supplier<String> randomQuote = () -> {
String[] quotes = {
"Stay hungry",
"Think different",
"Just do it"
};
return quotes[new Random()
.nextInt(quotes.length)];
};

String quote = randomQuote.get();

7

ğŸ”— Method References

Method reference je joÅ¡ kraÄ‡i naÄin pisanja lambda izraza
kada lambda samo poziva postojeÄ‡u metodu.

Sintaksa: Class::method

Lambda izraz

// Lambda koji poziva metodu
users.forEach(user ->
System.out.println(user)
);

Method Reference

// Ista stvar, kraÄ‡e
users.forEach(System.out::println);

ğŸ¯ Vrste Method References:

1. Reference na statiÄku metodu
// Parsiranje brojeva iz stringa
List<String> numbers = List.of("1", "2", "3");

// Lambda:
numbers.stream().map(s -> Integer.parseInt(s));

// Method reference:
numbers.stream().map(Integer::parseInt);

2. Reference na instance metodu objekta
// Filtriranje praznih stringova
List<String> hashtags = List.of("#java", "", "#coding");

// Lambda:
hashtags.stream().filter(s -> !s.isEmpty());

// Method reference:
hashtags.stream().filter(String::isEmpty).map(s -> !s);

3. Reference na konstruktor
// Kreiranje User objekata
List<String> usernames = List.of("alice", "bob", "charlie");

// Lambda:
usernames.stream().map(name -> new User(name));

// Method reference:
usernames.stream().map(User::new);

8

ğŸŒŠ Stream API + Lambda = ğŸ”¥

Stream API omoguÄ‡ava funkcionalno procesiranje kolekcija.
Lambda izrazi Äine Stream API moÄ‡nim i lakim za koriÅ¡tenje!

ğŸ’¡ Razmisli o Stream-u kao o "conveyor belt-u"

Podatke stavljaÅ¡ na "traku" (stream), primjenjujeÅ¡ operacije (filter, map),
i na kraju dobijeÅ¡ rezultat (collect, count, etc.)

Instagram primjer - najpopularniji postovi
// Lista Instagram postova
List<Post> posts = getInstagramPosts();

// Zadatak: NaÄ‘i top 5 postova s najviÅ¡e lajkova iz 2024.
List<Post> topPosts = posts.stream()
.filter(post -> post.getYear() == 2024)           // 1. Filtriraj po godini
.filter(post -> post.getLikes() > 10000)           // 2. Samo popularne
.sorted(Comparator.comparingInt(Post::getLikes)
.reversed())                                // 3. Sortiraj silazno
.limit(5)                                          // 4. Uzmi top 5
.collect(Collectors.toList());                     // 5. Sakupi u listu

// ğŸ‰ Sve u 6 linija Äitljivog koda!

ğŸš€ Stream operacije

filter() - filtrira elemente (vraÄ‡a boolean)
map() - transformira elemente (vraÄ‡a novi tip)
sorted() - sortira elemente
limit() - ograniÄava broj elemenata
collect() - sakuplja rezultate u kolekciju

9

ğŸ® Stream API - Gaming Primjeri

Primjer 1: Spotify - omiljene pjesme
// Filtriraj sve rock pjesme duÅ¾e od 3 minute
List<Song> playlist = songs.stream()
.filter(song -> "Rock".equals(song.getGenre()))
.filter(song -> song.getDuration() > 180)
.collect(Collectors.toList());

// ProsjeÄna duljina svih rock pjesama
double avgDuration = songs.stream()
.filter(song -> "Rock".equals(song.getGenre()))
.mapToInt(Song::getDuration)
.average()
.orElse(0.0);

Primjer 2: Gaming leaderboard
// Top 10 igraÄa po score-u
List<Player> topPlayers = players.stream()
.sorted(Comparator.comparingInt(Player::getScore).reversed())
.limit(10)
.collect(Collectors.toList());

// Ukupni score svih aktivnih igraÄa
int totalScore = players.stream()
.filter(Player::isActive)
.mapToInt(Player::getScore)
.sum();

// PronaÄ‘i najboljeg igraÄa
Optional<Player> bestPlayer = players.stream()
.max(Comparator.comparingInt(Player::getScore));

Primjer 3: E-commerce - koÅ¡arica
// IzraÄunaj ukupnu cijenu artikala na popustu
double total = cart.getItems().stream()
.filter(Item::hasDiscount)
.mapToDouble(item -> item.getPrice() * (1 - item.getDiscount()))
.sum();

// Grupiraj artikle po kategoriji
Map<String, List<Item>> byCategory = cart.getItems().stream()
.collect(Collectors.groupingBy(Item::getCategory));

10

ğŸ”„ map() - Transformacije podataka

map() transformira svaki element u stream-u.
Prima jedan tip, vraÄ‡a drugi tip.

TikTok primjer - formatiranje usernames
// Od liste imena do liste @usernames
List<String> names = List.of("Ana", "Marko", "Ivana");

List<String> usernames = names.stream()
.map(name -> "@" + name.toLowerCase())
.collect(Collectors.toList());

// Rezultat: ["@ana", "@marko", "@ivana"]

YouTube primjer - ekstrakcija podataka
// Od Video objekata do naslova videa
List<Video> videos = getVideos();

List<String> titles = videos.stream()
.map(Video::getTitle)
.collect(Collectors.toList());

// Ukupno pregleda svih videa
long totalViews = videos.stream()
.map(Video::getViews)
.reduce(0L, Long::sum);

// Ili kraÄ‡e:
long totalViews2 = videos.stream()
.mapToLong(Video::getViews)
.sum();

Netflix primjer - transformacija Movie -> DTO
// Pretvori Movie objekte u jednostavne DTO-ove
List<MovieDTO> movieCards = movies.stream()
.map(movie -> new MovieDTO(
movie.getTitle(),
movie.getThumbnail(),
movie.getRating()
))
.collect(Collectors.toList());

ğŸ’¡ Kada koristiti map()?
Koristi map() kada trebaÅ¡:

Pretvoriti objekte iz jednog tipa u drugi
Ekstraktirati odreÄ‘eno polje iz objekta
Primijeniti funkciju na svaki element

11

ğŸ—ºï¸ flatMap() - "Ravnanje" struktura

flatMap() se koristi kada imaÅ¡ "kolekciju kolekcija"
i Å¾eliÅ¡ je "spljoÅ¡titi" u jednu kolekciju.

map() - bez ravnanja

// Svaki korisnik ima listu prijatelja
List<User> users = getUsers();

// map() vraÄ‡a Stream<List<User>>
Stream<List<User>> friendLists =
users.stream()
.map(User::getFriends);

// ğŸ˜• Lista listi, ne moÅ¾emo lako raditi

flatMap() - s ravnanjem

// Svaki korisnik ima listu prijatelja
List<User> users = getUsers();

// flatMap() vraÄ‡a Stream<User>
List<User> allFriends =
users.stream()
.flatMap(user -> user.getFriends().stream())
.collect(Collectors.toList());

// ğŸ‰ Jedna ravna lista svih prijatelja!

Snapchat primjer - svi hashtagovi
// Svaki story ima viÅ¡e hashtagova
List<Story> stories = getStories();

// Izvuci sve hashtagove iz svih storyja
List<String> allHashtags = stories.stream()
.flatMap(story -> story.getHashtags().stream())
.distinct()  // Ukloni duplikate
.collect(Collectors.toList());

// Rezultat: [#summer, #fun, #travel, #food, ...]

Discord primjer - svi Älanovi servera
// Svaki server (guild) ima viÅ¡e kanala, svaki kanal viÅ¡e Älanova
List<Guild> guilds = getGuilds();

Set<User> allMembers = guilds.stream()
.flatMap(guild -> guild.getChannels().stream())  // Stream kanala
.flatMap(channel -> channel.getMembers().stream()) // Stream Älanova
.collect(Collectors.toSet());  // Set automatski uklanja duplikate

12

ğŸ¯ Collectors - Sakupljanje rezultata

Collectors omoguÄ‡avaju pretvaranje stream-a u razliÄite strukture podataka.

toList() / toSet()

// U listu
List<String> list = stream
.collect(Collectors.toList());

// U set (bez duplikata)
Set<String> set = stream
.collect(Collectors.toSet());

joining()

// Spoji stringove
String hashtags = tags.stream()
.collect(Collectors.joining(", "));

// Result: "java, coding, tech"

groupingBy()

// Grupiraj po Å¾anru
Map<String, List<Song>> byGenre =
songs.stream()
.collect(Collectors
.groupingBy(Song::getGenre));

partitioningBy()

// Podijeli u dvije grupe (true/false)
Map<Boolean, List<User>> byStatus =
users.stream()
.collect(Collectors
.partitioningBy(User::isActive));

Instagram Analytics primjer
// Broj postova po danu u tjednu
Map<DayOfWeek, Long> postsByDay = posts.stream()
.collect(Collectors.groupingBy(
post -> post.getDate().getDayOfWeek(),
Collectors.counting()
));

// ProsjeÄan broj lajkova po tipu posta
Map<PostType, Double> avgLikesByType = posts.stream()
.collect(Collectors.groupingBy(
Post::getType,
Collectors.averagingInt(Post::getLikes)
));

13

âš ï¸ ÄŒeste greÅ¡ke s Lambda izrazima

âŒ GREÅ KA #1: Mutiranje vanjskih varijabli

LoÅ¡e - Side effects

int sum = 0; // Outer variable
numbers.forEach(n -> {
sum += n; // âŒ ERROR: Variable used in lambda
// must be final or effectively final
});

Dobro - Funkcionalni pristup

// Koristi reduce() za agregaciju
int sum = numbers.stream()
.reduce(0, Integer::sum);

// Ili sum() za primitive
int sum2 = numbers.stream()
.mapToInt(Integer::intValue)
.sum();

âŒ GREÅ KA #2: PresloÅ¾ene lambde

LoÅ¡e - NeÄitljivo

// ğŸ˜µ PreviÅ¡e logike u lambdi
users.stream()
.filter(u -> {
if (u.getAge() > 18) {
if (u.isActive()) {
if (u.getFollowers() > 1000) {
return true;
}
}
}
return false;
});

Dobro - Jasno i Äisto

// ğŸ˜Š Izdvoji u zasebnu metodu
users.stream()
.filter(this::isInfluencer);

private boolean isInfluencer(User u) {
return u.getAge() > 18
&& u.isActive()
&& u.getFollowers() > 1000;
}

âŒ GREÅ KA #3: Zanemarivanje null vrijednosti

// âŒ MoÅ¾e baciti NullPointerException
users.stream()
.map(User::getName)  // getName() moÅ¾e vratiti null!
.map(String::toUpperCase)  // ğŸ’¥ NPE!
.collect(Collectors.toList());

// âœ… Sigurniji pristup
users.stream()
.map(User::getName)
.filter(Objects::nonNull)  // Filtriraj null-ove
.map(String::toUpperCase)
.collect(Collectors.toList());

// âœ… Ili koristi Optional
users.stream()
.map(User::getNameOptional)
.flatMap(Optional::stream)  // Java 9+
.map(String::toUpperCase)
.collect(Collectors.toList());

14

âœ¨ Best Practices

1ï¸âƒ£ Koristi method reference kada je moguÄ‡e

// Dobro âœ…
list.forEach(System.out::println);

// Meh, moÅ¾e bolje
list.forEach(x -> System.out.println(x));

2ï¸âƒ£ Izbjegavaj side effects
Lambda izrazi trebaju biti pure functions - bez mutiranja stanja!

// Dobro âœ…
return users.stream()
.filter(User::isActive)
.collect(Collectors.toList());

// LoÅ¡e âŒ
List<User> result = new ArrayList<>();
users.forEach(u -> {
if (u.isActive()) {
result.add(u); // Side effect!
}
});

3ï¸âƒ£ Lambda ili obiÄan loop?
Koristi lambdu kada operacija treba biti deklarativna.

// Lambda - za transformacije âœ…
names.stream()
.map(String::toUpperCase)
.collect(Collectors.toList());

// Loop - za kompleksnu logiku âœ…
for (User user : users) {
if (complexCondition(user)) {
doMultipleThings(user);
updateDatabase(user);
}
}

4ï¸âƒ£ Ime lambda parametara
Koristi smislena imena, ne generiÄka x, y.

// Dobro âœ…
users.stream()
.filter(user -> user.getAge() > 18)
.map(user -> user.getName())

// LoÅ¡e âŒ
users.stream()
.filter(u -> u.getAge() > 18)
.map(u -> u.getName())

15

âš¡ Performance Savjeti

1. Parallel Streams - PaÅ¾ljivo!

// Parallel stream za velike kolekcije
List<Integer> numbers = IntStream.range(1, 1_000_000)
.boxed()
.collect(Collectors.toList());

// Sequential (obiÄni stream)
long sum1 = numbers.stream()
.mapToLong(Integer::longValue)
.sum();

// Parallel - koristi viÅ¡e CPU cores
long sum2 = numbers.parallelStream()
.mapToLong(Integer::longValue)
.sum();

// âš ï¸ PAZI: Parallel je brÅ¾i samo za:
// - Velike koliÄine podataka (>10,000 elemenata)
// - CPU-intensive operacije
// - Bez side effects i shared state!

2. Lazy Evaluation
Stream operacije su lazy - izvrÅ¡avaju se tek kad pozoveÅ¡ terminal operaciju!

// NiÅ¡ta se NE izvrÅ¡ava ovdje!
Stream<User> stream = users.stream()
.filter(user -> {
System.out.println("Filtering " + user.getName());
return user.isActive();
})
.map(user -> {
System.out.println("Mapping " + user.getName());
return user.getName();
});

// IzvrÅ¡ava se tek kad pozoveÅ¡ terminal operaciju:
List<String> names = stream.collect(Collectors.toList());

// ğŸ’¡ Ovo je odliÄno za performanse - ne procesira sve podatke
// ako koristiÅ¡ npr. findFirst() ili limit()!

3. Short-circuiting operacije

// anyMatch() - prestaje Äim naÄ‘e match âœ…
boolean hasActiveUsers = users.stream()
.anyMatch(User::isActive);  // Zaustavlja se na prvom true

// findFirst() - vraÄ‡a odmah prvog âœ…
Optional<User> admin = users.stream()
.filter(User::isAdmin)
.findFirst();  // Ne procesira ostale elemente

// limit() - ograniÄava broj elemenata âœ…
List<User> first10 = users.stream()
.limit(10)
.collect(Collectors.toList());  // Procesira samo 10

ğŸ’¡ Golden Rule
Nemoj prerano optimizirati!
Prvo napiÅ¡i Äitljiv kod, pa optimiziraj ako je potrebno.
Stream API je uglavnom dovoljno brz za veÄ‡inu sluÄajeva.

16

ğŸ†• Å to je novo u Java 25?

1. Pattern Matching u lambdama (Preview)

// Tradicionalno
users.stream()
.filter(user -> user instanceof PremiumUser)
.map(user -> (PremiumUser) user)
.forEach(premium -> System.out.println(premium.getBenefits()));

// Java 25 - Pattern matching u lambdama
users.stream()
.filter(PremiumUser premium -> premium.getSubscription().isActive())
.forEach(premium -> System.out.println(premium.getBenefits()));

2. Enhanced Stream API

// Nove metode za lakÅ¡u obradu
List<Post> posts = getPosts();

// mapMulti() - alternative za flatMap
posts.stream()
.mapMulti((post, consumer) -> {
post.getTags().forEach(consumer);
})
.distinct()
.forEach(System.out::println);

// takeWhile() i dropWhile() za ordered streams
List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6);

numbers.stream()
.takeWhile(n -> n < 4)  // [1, 2, 3]
.forEach(System.out::println);

numbers.stream()
.dropWhile(n -> n < 4)  // [4, 5, 6]
.forEach(System.out::println);

3. Record Patterns u lambdama

// Record definicija
record User(String name, int age, String email) {}

// Dekonstrukcija u lambdi
List<User> users = getUsers();

users.stream()
.map(user -> switch (user) {
case User(var name, var age, var email)
when age > 18 -> "Adult: " + name;
case User(var name, var age, var email)
-> "Minor: " + name;
})
.forEach(System.out::println);

ğŸš€ Stay Updated!
Java se brzo razvija! Prati OpenJDK
za najnovije znaÄajke i JEP-ove (Java Enhancement Proposals).

17

ğŸ¯ PraktiÄni projekt: Social Media Analytics

Zadatak: Analiza Instagram postova

Kreiraj sustav za analizu popularnosti postova koristeÄ‡i Stream API i lambde.

Model klase
record Post(
String id,
String author,
String content,
int likes,
int comments,
int shares,
LocalDateTime postedAt,
List<String> hashtags
) {
// Engagement rate calculation
public double engagementRate() {
return (likes + comments * 2 + shares * 3) / 100.0;
}
}

Analytics klasa
public class InstagramAnalytics {

// 1. Top 10 postova po engagement rate-u
public List<Post> getTopEngagingPosts(List<Post> posts) {
return posts.stream()
.sorted(Comparator.comparingDouble(Post::engagementRate).reversed())
.limit(10)
.collect(Collectors.toList());
}

// 2. NajÄeÅ¡Ä‡i hashtagovi
public Map<String, Long> getTopHashtags(List<Post> posts, int limit) {
return posts.stream()
.flatMap(post -> post.hashtags().stream())
.collect(Collectors.groupingBy(
tag -> tag,
Collectors.counting()
))
.entrySet().stream()
.sorted(Map.Entry.<String, Long>comparingByValue().reversed())
.limit(limit)
.collect(Collectors.toMap(
Map.Entry::getKey,
Map.Entry::getValue,
(e1, e2) -> e1,
LinkedHashMap::new
));
}

// 3. Autori s prosjeÄno najviÅ¡e lajkova
public Map<String, Double> getTopAuthors(List<Post> posts) {
return posts.stream()
.collect(Collectors.groupingBy(
Post::author,
Collectors.averagingInt(Post::likes)
))
.entrySet().stream()
.sorted(Map.Entry.<String, Double>comparingByValue().reversed())
.limit(5)
.collect(Collectors.toMap(
Map.Entry::getKey,
Map.Entry::getValue,
(e1, e2) -> e1,
LinkedHashMap::new
));
}

// 4. Postovi iz zadnjih 24 sata
public List<Post> getRecentPosts(List<Post> posts) {
LocalDateTime yesterday = LocalDateTime.now().minusHours(24);
return posts.stream()
.filter(post -> post.postedAt().isAfter(yesterday))
.sorted(Comparator.comparing(Post::postedAt).reversed())
.collect(Collectors.toList());
}
}

18

ğŸ› Debugging Lambda izraza

Tipovi greÅ¡aka i kako ih rijeÅ¡iti

1. Debug sa peek()
// peek() omoguÄ‡ava inspekciju elemenata bez mijenjanja stream-a
List<String> result = users.stream()
.filter(User::isActive)
.peek(user -> System.out.println("After filter: " + user))
.map(User::getName)
.peek(name -> System.out.println("After map: " + name))
.collect(Collectors.toList());

// Output:
// After filter: User[name=Ana, active=true]
// After map: Ana
// After filter: User[name=Marko, active=true]
// After map: Marko

2. Breakpoints u IntelliJ IDEA
// Postavi breakpoint na liniju s lambdom
users.stream()
.filter(user -> user.getAge() > 18)  // â† Breakpoint ovdje
.collect(Collectors.toList());

// IntelliJ Ä‡e stati na svakom pozivu lambde!
// MoÅ¾eÅ¡ vidjeti vrijednosti user objekta

3. Izvuci lambdu u zasebnu metodu
// LoÅ¡e - teÅ¡ko za debug
users.stream()
.filter(u -> u.getAge() > 18 && u.isActive() && u.hasEmail())
.collect(Collectors.toList());

// Dobro - lako za debug
users.stream()
.filter(this::isEligible)
.collect(Collectors.toList());

private boolean isEligible(User user) {
// Ovdje moÅ¾eÅ¡ staviti breakpoint i vidjeti sve!
boolean adultAge = user.getAge() > 18;
boolean active = user.isActive();
boolean hasEmail = user.hasEmail();
return adultAge && active && hasEmail;
}

ğŸ’¡ Pro Debugging Tip
Koristi Stream.of().toList() za brzo testiranje lambda logike:

// Brzo testiraj svoju lambdu
List<String> test = Stream.of("Ana", "Marko", "Ivana")
.map(name -> "@" + name.toLowerCase())
.toList();

System.out.println(test); // [@ana, @marko, @ivana]

19

ğŸ“ ZakljuÄak

ğŸ“ Å to smo nauÄili?

Lambda sintaksu i funkcionalna suÄelja
Method references za kraÄ‡i kod
Stream API za elegantnu obradu podataka
Best practices i Äeste greÅ¡ke
Novosti u Java 25

ğŸ’ª Key Takeaways

Lambda = KraÄ‡i, Äitljiviji kod
Stream API = Deklarativno programiranje
Izbjegavaj side effects
Koristi method references
PiÅ¡i Äist, funkcionalan kod

ğŸš€ Sretno s kodiranjem!

Lambda izrazi su moÄ‡an alat - koristi ih mudro! ğŸ’¡

ğŸ“š Dodatni resursi

Oracle Java Tutorials: Lambda Expressions
Baeldung: OdliÄan izvor za Java tutorijale
Java Stream API Documentation: SluÅ¾bena dokumentacija
Modern Java in Action: PreporuÄena knjiga

Lambda izrazi
ğŸ“‹ SadrÅ¾aj vjeÅ¾bi

Primjeri jednostavnih lambda izraza
NajÄeÅ¡Ä‡e operacije s tokovima (Streams)
Sortiranje elemenata zbirke pomoÄ‡u tokova
Primjeri koriÅ¡tenja referenci za metode
KoriÅ¡tenje paralelizma
Usporedba performansi sekvencijalnih i paralelnih tokova
Moderne lambda izraze u Java 17-25 NOVO

ğŸ¯ Primjeri jednostavnih lambda izraza

Osnovna sintaksa
// Lambda bez parametara
() -> System.out.println("Hello Lambda");

// Lambda s jednim parametrom
x -> x + 10;

// Lambda s viÅ¡e parametara i eksplicitnim tipovima
(int x, int y) -> {
return x + y;
};

// Lambda koja vraÄ‡a razliku duljina stringova
(String x, String y) -> x.length() - y.length();

// Lambda s viÅ¡e naredbi
(String x) -> {
listA.add(x);
listB.remove(x);
return listB.size();
};

ğŸ’¡ KljuÄne karakteristike:

Lambda izrazi su kratki zapisi anonimnih funkcija
Mogu primiti 0 ili viÅ¡e parametara
Znak "->" odvaja parametre od tijela lambda izraza
Kompajler automatski odreÄ‘uje tipove parametara iz konteksta

ğŸ”„ Prije i poslije lambda izraza

âŒ Stari pristup (anonimna klasa)

button.addActionListener(
new ActionListener() {
public void actionPerformed(
ActionEvent event) {
System.out.println(
"button clicked");
}
}
);

âœ… Novi pristup (lambda izraz)

button.addActionListener(
event ->
System.out.println(
"button clicked!")
);

ğŸ‰ Prednosti lambda izraza:

KraÄ‡i i Äitljiviji kod (75% manje koda!)
Manje ceremonije i boilerplate koda
Fokus na funkcionalnost umjesto na sintaksu

ğŸ“ VaÅ¾ne napomene o lambda izrazima

ProsljeÄ‘ivanje bloka koda: Umjesto prosljeÄ‘ivanja objekta, prosljeÄ‘uje se funkcija bez imena

Parametri: "event" predstavlja naziv parametra i jednak je nazivu parametra u originalnoj metodi

Operator strelice (->): Odvaja parametre od tijela lambda izraza

Automatsko odreÄ‘ivanje tipova: Kompajler odreÄ‘uje tip parametra "event" iz konteksta metode "addActionListener"

Opcionalnost tipova: Tipovi parametara se ne moraju navoditi ako je oÄito o kojim tipovima se radi

Primjer type inference
// Kompajler automatski zna da je event tipa ActionEvent
button.addActionListener(event -> doSomething(event));

// MoÅ¾emo i eksplicitno navesti tip
button.addActionListener((ActionEvent event) -> doSomething(event));

ğŸŒŸ Lambda izrazi u razliÄitim situacijama

Bez argumenata
Runnable noArguments = () -> System.out.println("Hello World");

// Runnable ima samo jednu metodu: public void run()
// Lambda izraz ne prima nikakve parametre

Jedan argument
ActionListener oneArgument =
event -> System.out.println("button clicked");

ViÅ¡e naredbi u tijelu
Runnable multiStatement = () -> {
System.out.print("Hello");
System.out.println(" World");
};

Eksplicitno navoÄ‘enje tipova
// Implicitno - kompajler sam zakljuÄuje tipove
BinaryOperator<Long> add = (x, y) -> x + y;

// Eksplicitno - mi navodimo tipove
BinaryOperator<Long> addExplicit =
(Long x, Long y) -> x + y;

ğŸš€ Moderne lambda u Java 17-25 NOVO

Pattern Matching u Lambda izrazima (Java 21+)

Pattern matching za instanciranje
// Kombinacija pattern matching i lambda izraza
List<Object> objects = List.of("Java", 42, 3.14, "Lambda");

objects.stream()
.filter(obj -> obj instanceof String s && s.length() > 4)
.forEach(System.out::println);

// Tradicionalni pristup bi zahtijevao cast:
objects.stream()
.filter(obj -> obj instanceof String)
.map(obj -> (String) obj)  // Ovaj cast viÅ¡e nije potreban!
.filter(s -> s.length() > 4)
.forEach(System.out::println);

Records i Lambda izrazi (Java 17+)

Rad sa zapisima
record Student(String ime, int bodovi) {}

List<Student> studenti = List.of(
new Student("Ana", 95),
new Student("Ivan", 87),
new Student("Marko", 92)
);

// Sortiranje pomoÄ‡u lambde
studenti.stream()
.sorted((s1, s2) -> s2.bodovi() - s1.bodovi())
.forEach(s -> System.out.println(
s.ime() + ": " + s.bodovi()));

ğŸ“¦ Stream operacija: collect

Osnovna collect operacija
List<String> collected = Stream.of("a", "b", "c")
.collect(Collectors.toList());

Karakteristike collect() operacije:

SluÅ¾i za generiranje liste iz vrijednosti unutar Stream-a
Spada u "eager" operacije (izvrÅ¡ava se odmah)
MoÅ¾e se koristiti za razliÄite tipove kolekcija (List, Set, Map...)

Moderne collect opcije (Java 16+) NOVO

Nova toList() metoda
// Java 16+ - jednostavnija sintaksa!
List<String> collected = Stream.of("a", "b", "c")
.toList();  // Nema potrebe za Collectors.toList()

// Ova lista je immutable (ne moÅ¾e se mijenjati)

Teeing collector (Java 12+)
// Kombinira rezultate dva collectora
record Statistics(double avg, long count) {}

Statistics stats = Stream.of(1, 2, 3, 4, 5)
.collect(Collectors.teeing(
Collectors.averagingInt(i -> i),
Collectors.counting(),
Statistics::new
));

ğŸ—ºï¸ Stream operacija: map

Osnovna map operacija
List<String> collected = Stream.of("a", "b", "hello")
.map(string -> string.toUpperCase())
.collect(Collectors.toList());

// Rezultat: ["A", "B", "HELLO"]

Å to radi map():

"Mapira" jednu skupinu vrijednosti u drugu
Transformira svaki element Stream-a
MoÅ¾e se koristiti za 1:1 mapiranje

Napredni primjeri map operacije

Kompleksnije transformacije
// Mapiranje objekata u njihove duljine
List<Integer> lengths = Stream.of("Java", "Lambda", "Stream")
.map(String::length)
.toList();

// Rezultat: [4, 6, 6]

// Mapiranje s records (Java 17+)
record Person(String name, int age) {}

List<String> names = Stream.of(
new Person("Ana", 20),
new Person("Ivan", 22)
)
.map(Person::name)
.toList();

ğŸ” Stream operacija: filter

Osnovno filtriranje
List<String> beginningWithNumbers =
Stream.of("a", "1abc", "abc1")
.filter(value -> Character.isDigit(value.charAt(0)))
.collect(Collectors.toList());

// Rezultat: ["1abc"]

Funkcionalnost filter():

SluÅ¾i za filtriranje vrijednosti prema zadanim kriterijima
VraÄ‡a novi Stream samo s elementima koji zadovoljavaju uvjet
Predicat (uvjet) mora vraÄ‡ati boolean vrijednost

Napredni primjeri filtriranja

ViÅ¡estruki filtri
List<String> result = Stream.of("Java", "Python", "C++", "JavaScript")
.filter(lang -> lang.length() > 4)
.filter(lang -> lang.contains("a"))
.toList();

// Rezultat: ["Java", "JavaScript"]

// Filtriranje s pattern matching (Java 21+)
List<Object> mixed = List.of("tekst", 42, "Java", 3.14);
List<String> onlyStrings = mixed.stream()
.filter(obj -> obj instanceof String)
.map(obj -> (String) obj)
.toList();

ğŸ“Š Stream operacije: min i max

PronalaÅ¾enje minimalnog elementa
Track shortestTrack = tracks.stream()
.min(Comparator.comparing(track -> track.getLength()))
.get();

// Ili kraÄ‡e s method reference:
Track shortestTrack = tracks.stream()
.min(Comparator.comparing(Track::getLength))
.get();

âš ï¸ VaÅ¾no: Metode min() i max() vraÄ‡aju Optional<T> jer Stream moÅ¾e biti prazan!

Siguran pristup s Optional (Java 8+)

Pravilno rukovanje Optional vrijednostima
// âŒ OPASNO - baca exception ako je stream prazan
Track shortest = tracks.stream()
.min(Comparator.comparing(Track::getLength))
.get();

// âœ… SIGURNO - koristi orElse
Track shortest = tracks.stream()
.min(Comparator.comparing(Track::getLength))
.orElse(null);

// âœ… NAJBOLJE - koristi ifPresent
tracks.stream()
.min(Comparator.comparing(Track::getLength))
.ifPresent(track ->
System.out.println("NajkraÄ‡i: " + track));

// âœ… MODERNO - orElseThrow (Java 10+)
Track shortest = tracks.stream()
.min(Comparator.comparing(Track::getLength))
.orElseThrow(() ->
new NoSuchElementException("Nema pjesama!"));

âš¡ Stream operacija: reduce

Osnovna reduce operacija
int count = Stream.of(1, 2, 3)
.reduce(0, (acc, element) -> acc + element);

// Rezultat: 6 (0 + 1 + 2 + 3)

Kako radi reduce():

Koristi se kad je iz zbirke vrijednosti potrebno odrediti jednu vrijednost
Prvi parametar je poÄetna vrijednost (identity)
Drugi parametar je akumulator funkcija koja kombinira vrijednosti

Napredni primjeri reduce operacije

RazliÄite primjene reduce
// RaÄunanje sume
int sum = Stream.of(1, 2, 3, 4, 5)
.reduce(0, Integer::sum);

// RaÄunanje produkta
int product = Stream.of(1, 2, 3, 4)
.reduce(1, (a, b) -> a * b);

// PronalaÅ¾enje maksimuma
Optional<Integer> max = Stream.of(1, 5, 3, 9, 2)
.reduce(Integer::max);

// Konkatenacija stringova
String concatenated = Stream.of("Java", "je", "super")
.reduce("", (a, b) -> a + " " + b)
.trim();

// Rezultat: "Java je super"

ğŸŒŠ Stream operacija: flatMap

Osnovna flatMap operacija
List<Integer> together = Stream.of(
Arrays.asList(1, 2),
Arrays.asList(3, 4)
)
.flatMap(numbers -> numbers.stream())
.collect(Collectors.toList());

// Rezultat: [1, 2, 3, 4]

Å to radi flatMap():

Koristi se za "spljoÅ¡tavanje" ugnijeÅ¾Ä‘enih kolekcija
Transformira svaki element u Stream i spaja sve Stream-ove u jedan
RjeÅ¡ava problem Stream<Stream<T>> â†’ Stream<T>

PraktiÄni primjeri flatMap-a

Rad s ugnijeÅ¾Ä‘enim strukturama
// Dobivanje svih rijeÄi iz liste reÄenica
List<String> sentences = List.of(
"Java je programski jezik",
"Lambda izrazi su korisni"
);

List<String> words = sentences.stream()
.flatMap(sentence -> Arrays.stream(sentence.split(" ")))
.toList();

// Rezultat: ["Java", "je", "programski", "jezik",
//           "Lambda", "izrazi", "su", "korisni"]

// Dobivanje svih kolegija svih studenata
record Student(String name, List<String> courses) {}

List<Student> students = List.of(
new Student("Ana", List.of("Java", "Python")),
new Student("Ivan", List.of("C++", "Java"))
);

List<String> allCourses = students.stream()
.flatMap(student -> student.courses().stream())
.distinct()
.toList();

// Rezultat: ["Java", "Python", "C++"]

ğŸ”— UlanÄavanje operacija kod tokova

Primjer ulanÄavanja
Set<String> origins = album.getMusicians()
.filter(artist -> artist.getName().startsWith("The"))
.map(artist -> artist.getNationality())
.collect(Collectors.toSet());

VaÅ¾no o ulanÄavanju:

Prvo se izvrÅ¡avaju "lazy" operacije (filter, map, flatMap...)
Na kraju se izvrÅ¡ava jedna "eager" operacija (collect, forEach, reduce...)
Lazy operacije se ne izvrÅ¡avaju dok ne naiÄ‘e eager operacija!

Kompleksan primjer ulanÄavanja (Java 17+)

Realni scenarij sa zapisima
record Proizvod(String naziv, double cijena, String kategorija) {}

List<Proizvod> proizvodi = List.of(
new Proizvod("Laptop", 5000.0, "Elektronika"),
new Proizvod("MiÅ¡", 150.0, "Elektronika"),
new Proizvod("Stol", 800.0, "NamjeÅ¡taj"),
new Proizvod("Stolica", 600.0, "NamjeÅ¡taj")
);

// PronaÄ‘i sve proizvode iz kategorije "Elektronika"
// Äija je cijena veÄ‡a od 1000 kn, sortiraj ih po cijeni
// i vrati njihove nazive
List<String> skupiElektronickiProizvodi = proizvodi.stream()
.filter(p -> p.kategorija().equals("Elektronika"))
.filter(p -> p.cijena() > 1000)
.sorted(Comparator.comparing(Proizvod::cijena).reversed())
.map(Proizvod::naziv)
.toList();

// Rezultat: ["Laptop"]

ğŸ”¢ Sortiranje elemenata zbirke pomoÄ‡u tokova

Osnovno sortiranje
Set<Integer> numbers = new HashSet<>(Arrays.asList(4, 3, 2, 1));

List<Integer> sameOrder = numbers.stream()
.sorted()
.collect(Collectors.toList());

// Rezultat: [1, 2, 3, 4]

Napredne tehnike sortiranja

Sortiranje s Comparator-ima
record Osoba(String ime, int dob) {}

List<Osoba> osobe = List.of(
new Osoba("Ana", 25),
new Osoba("Marko", 30),
new Osoba("Ivan", 20)
);

// Sortiranje po dobi (ascending)
List<Osoba> sortedByAge = osobe.stream()
.sorted(Comparator.comparing(Osoba::dob))
.toList();

// Sortiranje po dobi (descending)
List<Osoba> sortedByAgeDesc = osobe.stream()
.sorted(Comparator.comparing(Osoba::dob).reversed())
.toList();

// ViÅ¡ekriterijsko sortiranje (prvo po dobi, pa po imenu)
List<Osoba> multiSort = osobe.stream()
.sorted(Comparator
.comparing(Osoba::dob)
.thenComparing(Osoba::ime))
.toList();

// Sortiranje stringova po duljini
List<String> words = List.of("Java", "Python", "C", "JavaScript");
List<String> sortedByLength = words.stream()
.sorted(Comparator.comparing(String::length))
.toList();

ğŸ¯ Primjeri koriÅ¡tenja referenci za metode

Å to su reference za metode (Method References)?
Kratki zapis lambda izraza koji samo poziva postojeÄ‡u metodu

Tipovi referenci za metode

1. StatiÄka metoda klase
// Lambda izraz
list.forEach(x -> System.out.println(x));

// Method reference
list.forEach(System.out::println);

2. Metoda instance objekta
// Lambda izraz
list.stream().map(s -> s.toUpperCase());

// Method reference
list.stream().map(String::toUpperCase);

3. Metoda konkretne instance
String prefix = "Hello ";

// Lambda izraz
list.stream().map(s -> prefix.concat(s));

// Method reference
list.stream().map(prefix::concat);

4. Konstruktor
// Lambda izraz
list.stream().map(s -> new StringBuilder(s));

// Method reference
list.stream().map(StringBuilder::new);

âš¡ KoriÅ¡tenje paralelizma

ZaÅ¡to paralelizam?

Maksimalno iskoriÅ¡tavanje viÅ¡ejezgrenog procesora
ZnaÄajno ubrzanje kod obrade velikih koliÄina podataka
Jednostavna upotreba - samo poziv parallelStream()

Serijski tok

public int serialArraySum() {
return albums.stream()
.flatMap(Album::getTracks)
.mapToInt(Track::getLength)
.sum();
}

Paralelni tok

public int parallelArraySum() {
return albums.parallelStream()
.flatMap(Album::getTracks)
.mapToInt(Track::getLength)
.sum();
}

Kada koristiti paralelne tokove?
// âœ… DOBRO - velika koliÄina podataka, raÄunski intenzivne operacije
long sum = IntStream.range(1, 10_000_000)
.parallel()
.map(x -> x * x)
.sum();

// âŒ LOÅ E - mala koliÄina podataka, overhead je veÄ‡i od koristi
long sum = IntStream.range(1, 100)
.parallel()
.sum();

// âŒ LOÅ E - operacije koje moraju biti sekvencijalne
list.parallelStream()
.forEachOrdered(System.out::println);  // Gubi smisao paralelizma!

ğŸ“Š Usporedba performansi sekvencijalnih i paralelnih tokova

Testni scenarij:

Polje od 10.000.000 long vrijednosti (od 1 do 1000)
RaÄunanje: count, sum, min, max, average
Tri pristupa:

Odvojeno izvoÄ‘enje operacija
Sekvencijalni tok
Paralelni tok

SljedeÄ‡i slajdovi pokazuju kompletan kod za usporedbu performansi...

ğŸ’» Kod za usporedbu performansi (1/4)

Inicijalizacija i odvojeno raÄunanje
public class StreamStatisticsComparison {
public static void main(String[] args) {
SecureRandom random = new SecureRandom();

// Kreiranje polja random long vrijednosti
long[] values = random.longs(10_000_000, 1, 1001).toArray();

// IzvoÄ‘enje raÄunanja odvojeno
Instant separateStart = Instant.now();
long count = Arrays.stream(values).count();
long sum = Arrays.stream(values).sum();
long min = Arrays.stream(values).min().getAsLong();
long max = Arrays.stream(values).max().getAsLong();
double average = Arrays.stream(values).average().getAsDouble();
Instant separateEnd = Instant.now();

ğŸ’» Kod za usporedbu performansi (2/4)

Ispis rezultata odvojenog raÄunanja
// Prikaz rezultata
System.out.println("Calculations performed separately");
System.out.printf("    count: %,d%n", count);
System.out.printf("      sum: %,d%n", sum);
System.out.printf("      min: %,d%n", min);
System.out.printf("      max: %,d%n", max);
System.out.printf("  average: %f%n", average);
System.out.printf("Total time in milliseconds: %d%n%n",
Duration.between(separateStart, separateEnd).toMillis());

// Sekvencijalni tok
LongStream stream1 = Arrays.stream(values);
System.out.println("Calculating statistics on sequential stream");
Instant sequentialStart = Instant.now();
LongSummaryStatistics results1 = stream1.summaryStatistics();
Instant sequentialEnd = Instant.now();

ğŸ’» Kod za usporedbu performansi (3/4)

Paralelni tok i ispis
// Prikaz rezultata sekvencijalnog toka
displayStatistics(results1);
System.out.printf("Total time in milliseconds: %d%n%n",
Duration.between(sequentialStart, sequentialEnd).toMillis());

// Paralelni tok
LongStream stream2 = Arrays.stream(values).parallel();
System.out.println("Calculating statistics on parallel stream");
Instant parallelStart = Instant.now();
LongSummaryStatistics results2 = stream2.summaryStatistics();
Instant parallelEnd = Instant.now();

// Prikaz rezultata paralelnog toka
displayStatistics(results2);
System.out.printf("Total time in milliseconds: %d%n%n",
Duration.between(parallelStart, parallelEnd).toMillis());
}

ğŸ’» Kod za usporedbu performansi (4/4)

Helper metoda za prikaz statistike
// Prikazuje LongSummaryStatistics vrijednosti
private static void displayStatistics(LongSummaryStatistics stats) {
System.out.println("Statistics");
System.out.printf("    count: %,d%n", stats.getCount());
System.out.printf("      sum: %,d%n", stats.getSum());
System.out.printf("      min: %,d%n", stats.getMin());
System.out.printf("      max: %,d%n", stats.getMax());
System.out.printf("  average: %f%n", stats.getAverage());
}
} // end class StreamStatisticsComparison

ğŸ“ˆ Rezultati usporedbe performansi

Pristup
Vrijeme (ms)
Relativno ubrzanje

Odvojeno izvoÄ‘enje
188 ms
-

Sekvencijalni tok
62 ms
3x brÅ¾e âš¡

Paralelni tok
47 ms
4x brÅ¾e âš¡âš¡

Potpuni ispis rezultata
Calculations performed separately
count: 10,000,000
sum: 5,006,045,362
min: 1
max: 1,000
average: 500.604536
Total time in milliseconds: 188

Calculating statistics on sequential stream
Statistics
count: 10,000,000
sum: 5,006,045,362
min: 1
max: 1,000
average: 500.604536
Total time in milliseconds: 62

Calculating statistics on parallel stream
Statistics
count: 10,000,000
sum: 5,006,045,362
min: 1
max: 1,000
average: 500.604536
Total time in milliseconds: 47

ğŸš€ Dodatni moderni primjeri (Java 17-25) BONUS

1. Text Blocks s Lambda izrazima (Java 15+)

Formatiranje JSON-a
List<String> names = List.of("Ana", "Ivan", "Marko");

String json = names.stream()
.map(name -> """
{
"name": "%s",
"timestamp": "%s"
}
""".formatted(name, Instant.now()))
.collect(Collectors.joining(","));

System.out.println("[" + json + "]");

2. Switch Expressions u Lambda izrazima (Java 14+)

Mapiranje vrijednosti sa switch
List<String> grades = List.of("A", "B", "C", "D", "F");

List<String> descriptions = grades.stream()
.map(grade -> switch (grade) {
case "A" -> "Izvrstan";
case "B" -> "Vrlo dobar";
case "C" -> "Dobar";
case "D" -> "Dovoljan";
default -> "Nedovoljan";
})
.toList();

3. Sequenced Collections (Java 21+)

Pristup prvom i zadnjem elementu
List<String> languages = List.of("Java", "Python", "C++", "JavaScript");

// Novi naÄini pristupa prvom i zadnjem elementu
String first = languages.getFirst();  // "Java"
String last = languages.getLast();    // "JavaScript"

// Reverzni stream
List<String> reversed = languages.reversed().stream()
.toList();

âœ¨ Najbolje prakse i savjeti

âœ… PreporuÄeno

Koristite method references gdje god je to moguÄ‡e - pregledniji je kod
DrÅ¾ite lambda izraze kratkim - idealno 1-3 linije
Koristite toList() umjesto collect(Collectors.toList()) u Java 16+
Preferirajte var za deklaracije varijabli s lambda izrazima (Java 10+)
Koristite Optional pravilno - izbjegavajte get() bez provjere

âŒ Izbjegavajte

Ne koristite paralelizam bez testiranja - nije uvijek brÅ¾i!
Izbjegavajte side effects u lambda izrazima - ne mijenjajte stanje izvan lambda izraza
Ne pretjerujte s ulanÄavanjem - pregledniji kod bitniji od "cool" faktora
Ne koristite peek() za debugging - lazy operacija ne mora se izvrÅ¡iti!

Primjer dobre prakse
// âœ… DOBRO
var activeUsers = users.stream()
.filter(User::isActive)
.map(User::getName)
.toList();

// âŒ LOÅ E - side effect
int count = 0;
users.stream()
.filter(u -> u.isActive())
.forEach(u -> count++);  // NE RADI! Kompajler error
