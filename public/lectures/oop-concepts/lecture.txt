
Java 25

ğŸ“Š UML Class Dijagram
Vozilo
- brojPutnika: int
- potrosnja: float
â†“
Automobil | Zrakoplov
- vrstaMotora: String | - rasponKrila: float
- brojVrata: int | - sirinaTrupa: float

Koncept: Osnovna nadklasa Vozilo sadrÅ¾i zajedniÄke atribute, dok podklase dodaju specifiÄne karakteristike

Nadklasa: Vozilo
public class Vozilo {

private int brojPutnika;
private float potrosnja;

public Vozilo(int brojPutnika, float potrosnja) {
this.brojPutnika = brojPutnika;
this.potrosnja = potrosnja;
}

// Getteri i setteri
public int getBrojPutnika() {
return brojPutnika;
}

public void setBrojPutnika(int brojPutnika) {
this.brojPutnika = brojPutnika;
}

public float getPotrosnja() {
return potrosnja;
}

public void setPotrosnja(float potrosnja) {
this.potrosnja = potrosnja;
}
}

Podklasa: Automobil
public class Automobil extends Vozilo {

// Konstante za vrste motora
public static final String VRSTA_MOTORA_BENZINSKI =
"VRSTA_MOTORA_BENZINSKI";
public static final String VRSTA_MOTORA_DIZEL =
"VRSTA_MOTORA_DIZEL";
public static final String VRSTA_MOTORA_HIBRIDNI =
"VRSTA_MOTORA_HIBRIDNI";
public static final String VRSTA_MOTORA_ELEKTRICNI =
"VRSTA_MOTORA_ELEKTRICNI";

private String vrstaMotora;
private int brojVrata;

public Automobil(String vrstaMotora, int brojVrata,
int brojPutnika, float potrosnja) {
// Poziv konstruktora nadklase
super(brojPutnika, potrosnja);
this.vrstaMotora = vrstaMotora;
this.brojVrata = brojVrata;
}

// Getteri i setteri
}

Podklasa: Zrakoplov
public class Zrakoplov extends Vozilo {

private float rasponKrila;
private float sirinaTrupa;

public Zrakoplov(int brojPutnika, float potrosnja,
float rasponKrila, float sirinaTrupa) {
// Poziv konstruktora nadklase
super(brojPutnika, potrosnja);
this.rasponKrila = rasponKrila;
this.sirinaTrupa = sirinaTrupa;
}

// Getteri i setteri
public float getRasponKrila() {
return rasponKrila;
}

public void setRasponKrila(float rasponKrila) {
this.rasponKrila = rasponKrila;
}

public float getSirinaTrupa() {
return sirinaTrupa;
}

public void setSirinaTrupa(float sirinaTrupa) {
this.sirinaTrupa = sirinaTrupa;
}
}

Kreiranje i usporedba vozila
public class Main {
public static void main(String[] args) {

// Kreiranje automobila
Automobil mojAuto = new Automobil(
Automobil.VRSTA_MOTORA_DIZEL,
5,      // broj vrata
4,      // broj putnika
6.7f    // potroÅ¡nja
);

// Kreiranje zrakoplova
Zrakoplov avion = new Zrakoplov(
400,        // broj putnika
234234,     // potroÅ¡nja
102,        // raspon krila
36          // Å¡irina trupa
);

// Usporedba
if (mojAuto.getBrojPutnika() > avion.getBrojPutnika()) {
System.out.println("Ovo je jako veliki auto!!!");
} else {
System.out.println("Avion je mnogo veÄ‡i!!!");
}
}
}

ğŸ¸ Primjer polimorfizma - Instrumenti

ğŸ“Š UML Class Dijagram
Instrument (abstract)
- vrstaInstrumenta: int
+ odsvirajNotu(): void (abstract)
â†“
Gitara | Flauta | Bubanj | Klavir | RitamMasina

Polimorfizam: Ista metoda (odsvirajNotu()), razliÄite implementacije za svaki instrument!

Apstraktna klasa: Instrument
public abstract class Instrument {

// Konstante za vrste instrumenata
public static final int VRSTA_INSTRUMENTA_PUHACKI = 1;
public static final int VRSTA_INSTRUMENTA_UDARALJKE = 2;
public static final int VRSTA_INSTRUMENTA_ZICANI = 3;
public static final int VRSTA_INSTRUMENTA_ELEKTRONICKI = 4;
public static final int VRSTA_INSTRUMENTA_KLAVIJATURE = 5;

private int vrstaInstrumenta;

// Getter i setter
public int getVrstaInstrumenta() {
return vrstaInstrumenta;
}

public void setVrstaInstrumenta(int vrstaInstrumenta) {
this.vrstaInstrumenta = vrstaInstrumenta;
}

// Apstraktna metoda - MORA se implementirati u podklasama
public abstract void odsvirajNotu();
}

Konkretna klasa: Gitara
public class Gitara extends Instrument {

public Gitara() {
setVrstaInstrumenta(VRSTA_INSTRUMENTA_ZICANI);
}

@Override
public void odsvirajNotu() {
System.out.println("ğŸ¸ Nota odsvirana gitarom!");
}
}

âœ… Implementacija: Svaka podklasa implementira odsvirajNotu() na svoj naÄin

Konkretna klasa: Flauta
public class Flauta extends Instrument {

public Flauta() {
setVrstaInstrumenta(VRSTA_INSTRUMENTA_PUHACKI);
}

@Override
public void odsvirajNotu() {
System.out.println("ğŸµ Nota odsvirana flautom!");
}
}

Konkretna klasa: Bubanj
public class Bubanj extends Instrument {

public Bubanj() {
setVrstaInstrumenta(VRSTA_INSTRUMENTA_UDARALJKE);
}

@Override
public void odsvirajNotu() {
System.out.println("ğŸ¥ Ritam odsviran bubnjem!");
}
}

Konkretna klasa: Klavir
public class Klavir extends Instrument {

public Klavir() {
setVrstaInstrumenta(VRSTA_INSTRUMENTA_KLAVIJATURE);
}

@Override
public void odsvirajNotu() {
System.out.println("ğŸ¹ Nota odsvirana klavirom!");
}
}

Konkretna klasa: RitamMasina
public class RitamMasina extends Instrument {

public RitamMasina() {
setVrstaInstrumenta(VRSTA_INSTRUMENTA_ELEKTRONICKI);
}

@Override
public void odsvirajNotu() {
System.out.println("ğŸ›ï¸ Ritam odsviran ritam-maÅ¡inom!");
}
}

Popunjavanje polja random instrumentima
private static Instrument[] popuniPoljeRandomInstrumentima(
Instrument[] instrumenti) {

Random random = new Random();

for (int i = 0; i < BROJ_INSTRUMENATA; i++) {
switch (random.nextInt(5)) {
case 0:
instrumenti[i] = new Flauta();
break;
case 1:
instrumenti[i] = new Bubanj();
break;
case 2:
instrumenti[i] = new Gitara();
break;
case 3:
instrumenti[i] = new Klavir();
break;
case 4:
instrumenti[i] = new RitamMasina();
break;
}
}

return instrumenti;
}

Polimorfizam u akciji!
public class Main {

public static final int BROJ_INSTRUMENATA = 10;

public static void main(String[] args) {

// Kreiranje polja instrumenata
Instrument[] instrumenti = new Instrument[BROJ_INSTRUMENATA];

// Popunjavanje polja random instrumentima
instrumenti = popuniPoljeRandomInstrumentima(instrumenti);

// Polimorfizam - pozivamo istu metodu na razliÄitim objektima
for (int i = 0; i < BROJ_INSTRUMENATA; i++) {
instrumenti[i].odsvirajNotu();
System.out.println(instrumenti[i].toString());
}
}
}

ğŸ¯ KljuÄ: Tipovi se odreÄ‘uju tijekom izvoÄ‘enja - ne moramo znati toÄan tip prilikom kompajliranja!

Primjer izvrÅ¡avanja

ğŸ¸ Nota odsvirana gitarom!
ğŸµ Nota odsvirana flautom!
ğŸ›ï¸ Ritam odsviran ritam-maÅ¡inom!
ğŸ¸ Nota odsvirana gitarom!
ğŸ¥ Ritam odsviran bubnjem!
ğŸ¸ Nota odsvirana gitarom!
ğŸ¸ Nota odsvirana gitarom!
ğŸµ Nota odsvirana flautom!
ğŸ¥ Ritam odsviran bubnjem!
ğŸµ Nota odsvirana flautom!

ğŸ’¡ ObjaÅ¡njenje: Svaki put se poziva razliÄita implementacija metode odsvirajNotu() ovisno o stvarnom tipu objekta!

âš¡ Primjer suÄelja: Elektricno

SuÄelja omoguÄ‡avaju dodavanje dodatnih svojstava klasama

public interface Elektricno {

void ukljuci();
void iskljuci();

}

Koncept: ElektriÄni instrumenti mogu se ukljuÄivati i iskljuÄivati - dodajemo im to svojstvo putem suÄelja

Implementacija suÄelja
public class RitamMasina extends Instrument
implements Elektricno {

private boolean ukljuceno;

public RitamMasina() {
setVrstaInstrumenta(VRSTA_INSTRUMENTA_ELEKTRONICKI);
ukljuceno = false;
}

@Override
public void odsvirajNotu() {
if (ukljuceno) {
System.out.println("ğŸ›ï¸ Ritam odsviran ritam-maÅ¡inom!");
} else {
System.out.println("âš ï¸ Ritam maÅ¡ina je iskljuÄena!!!");
}
}

@Override
public void ukljuci() {
ukljuceno = true;
System.out.println("âœ… Ritam maÅ¡ina ukljuÄena!");
}

@Override
public void iskljuci() {
ukljuceno = false;
System.out.println("âŒ Ritam maÅ¡ina iskljuÄena!");
}
}

ğŸ¸ NadjaÄavanje u viÅ¡im razinama

Klase mogu nasljeÄ‘ivati i druge podklase, ne samo nadklase!

// Gitara veÄ‡ nasljeÄ‘uje Instrument
public class Gitara extends Instrument {

@Override
public void odsvirajNotu() {
System.out.println("ğŸ¸ Nota odsvirana gitarom!");
}
}

// BasGitara nasljeÄ‘uje Gitaru i dalje nadjaÄava metodu
public class BasGitara extends Gitara {

@Override
public void odsvirajNotu() {
System.out.println("ğŸ¸ğŸ”Š Nota odsvirana bas gitarom!");
}
}

ğŸŒ³ Hijerarhija: Instrument â†’ Gitara â†’ BasGitara

ğŸ“ Metoda toString()

Metoda toString() iz klase Object omoguÄ‡ava definiranje kako Ä‡e se objekt prikazati kao String

Defaultna implementacija
// Bez nadjaÄavanja
Flauta flauta = new Flauta();
System.out.println(flauta);

// Output:
// polimorfizam.Flauta@f62373
âŒ Nije informativno!

NadjaÄana implementacija
@Override
public String toString() {
return "Flauta je vrsta " +
"instrumenta pod rednim " +
"brojem " +
getVrstaInstrumenta();
}

// Output:
// Flauta je vrsta instrumenta
// pod rednim brojem 1
âœ… Informativno i Äitljivo!

ğŸ”„ Sortiranje s lambda funkcijama

SuÄelje Comparator:

Samo jedna apstraktna metoda: compare(T o1, T o2)
VraÄ‡a rezultat usporedbe:

Negativan broj
Prvi argument je manji od drugog

0 (nula)
Argumenti su jednaki

Pozitivan broj
Prvi argument je veÄ‡i od drugog

ğŸ’¡ Klasa Arrays: StatiÄke metode za rad s poljima, ukljuÄujuÄ‡i sort()

Lambda izraz za sortiranje
import java.util.Arrays;

public class Test {
public static void main(String[] args) {

// Polje stringova
String[] prezimena = new String[5];
prezimena[0] = "IvaniÄ‡";
prezimena[1] = "Å½arniÄ‡";
prezimena[2] = "AniÄ‡";
prezimena[3] = "PeriÄ‡";
prezimena[4] = "Horvat";

// Sortiranje s lambda izrazom
Arrays.sort(prezimena, (p1, p2) -> p1.compareTo(p2));

// Ispis sortiranog polja
System.out.println(Arrays.toString(prezimena));
// Output: [AniÄ‡, Horvat, IvaniÄ‡, PeriÄ‡, Å½arniÄ‡]
}
}

âœ¨ Lambda izraz: (p1, p2) -> p1.compareTo(p2) zamjenjuje cijelu anonimnu klasu!

ğŸ” Operator instanceof

Operator instanceof provjerava je li objekt instanca odreÄ‘ene klase

public class Main {
public static void main(String[] args) {

Osoba[] osobe = new Osoba[5];
osobe[0] = new Zaposlenik("Horvat", "Ivan");
osobe[1] = new Klijent("AniÄ‡", "Ana");
osobe[2] = new Zaposlenik("PeriÄ‡", "Petra");
// ...

for (Osoba osoba : osobe) {
System.out.println("Prezime i ime: " +
osoba.getPrezime() + " " +
osoba.getIme());

// Provjera tipa objekta
boolean isZaposlenik = osoba instanceof Zaposlenik;

if (isZaposlenik) {
System.out.println("âœ… Osoba je zaposlenik");
} else {
System.out.println("ğŸ‘¤ Osoba je klijent");
}
}
}
}

âœ¨ Java 16+: Pattern Matching

Novost: Pattern matching za instanceof - automatsko castanje!

Stari naÄin (do Java 15)
if (animal instanceof Cat) {
// Moramo ruÄno castati
Cat cat = (Cat) animal;
return cat.meow();
}

Novi naÄin (Java 16+)
// Automatski cast u varijablu 'cat'
if (animal instanceof Cat cat) {
return cat.meow();
}

ğŸ¯ Prednosti: KraÄ‡i kod, manje greÅ¡aka, bolja Äitljivost!

Pattern Matching - Napredni primjer
public class InstrumentProcessor {

public static void obradiInstrument(Instrument instrument) {

// Pattern matching s automatskim castanjem
if (instrument instanceof Gitara gitara) {
System.out.println("ğŸ¸ Å½iÄani instrument");
gitara.odsvirajNotu();
}
else if (instrument instanceof RitamMasina masina) {
System.out.println("ğŸ›ï¸ ElektroniÄki instrument");
masina.ukljuci();
masina.odsvirajNotu();
masina.iskljuci();
}
else if (instrument instanceof Bubanj bubanj) {
System.out.println("ğŸ¥ Udaraljka");
bubanj.odsvirajNotu();
}
else {
System.out.println("ğŸµ Ostali instrument");
instrument.odsvirajNotu();
}
}
}

ğŸ—ï¸ Builder Pattern

Problem: Konstruktori s puno parametara, od kojih neki mogu biti null

LoÅ¡a praksa:
// PreviÅ¡e parametara, nije jasno Å¡to je Å¡to
Student student = new Student(
"12345678910",  // OIB
"Horvat",       // prezime
"Ivan",         // ime
null,           // email - nije dostupan
null,           // telefon - nije dostupan
"Zagreb",       // grad
4.5             // prosjek
);

ğŸ’¡ RjeÅ¡enje: Builder Pattern - postavljamo samo dostupne parametre!

Builder Pattern - Implementacija (1/3)
public class Student {

private final String oib;
private final String prezime;
private final String ime;
private final String email;
private final String telefon;
private final String grad;
private final double prosjek;

// Privatni konstruktor - poziva ga samo Builder
private Student(StudentBuilder builder) {
this.oib = builder.oib;
this.prezime = builder.prezime;
this.ime = builder.ime;
this.email = builder.email;
this.telefon = builder.telefon;
this.grad = builder.grad;
this.prosjek = builder.prosjek;
}

// Getteri...
public String getOib() { return oib; }
public String getPrezime() { return prezime; }
// ...
}

Builder Pattern - Implementacija (2/3)
// StatiÄka ugnijeÅ¾Ä‘ena klasa Builder
public static class StudentBuilder {

// Obavezni parametri
private final String oib;
private final String prezime;
private final String ime;

// Opcionalni parametri - defaultne vrijednosti
private String email = "";
private String telefon = "";
private String grad = "";
private double prosjek = 0.0;

// Konstruktor sa obaveznim parametrima
public StudentBuilder(String oib, String prezime, String ime) {
this.oib = oib;
this.prezime = prezime;
this.ime = ime;
}

// Metode za postavljanje opcionalnih parametara
public StudentBuilder email(String email) {
this.email = email;
return this;
}
// ...nastavlja se na sljedeÄ‡em slajdu
}

Builder Pattern - Implementacija (3/3)
// Nastavak Builder klase...

public StudentBuilder telefon(String telefon) {
this.telefon = telefon;
return this;
}

public StudentBuilder grad(String grad) {
this.grad = grad;
return this;
}

public StudentBuilder prosjek(double prosjek) {
this.prosjek = prosjek;
return this;
}

// Build metoda - kreira finalni objekt
public Student build() {
return new Student(this);
}
}

Builder Pattern - KoriÅ¡tenje
public class Main {
public static void main(String[] args) {

// Kreiranje studenta s SVIM podacima
Student student1 = new Student.StudentBuilder(
"12345678910", "Horvat", "Ivan"
)
.email("ivan.horvat@foi.hr")
.telefon("098-123-4567")
.grad("Zagreb")
.prosjek(4.5)
.build();

// Kreiranje studenta sa SAMO OBAVEZNIM podacima
Student student2 = new Student.StudentBuilder(
"10987654321", "AniÄ‡", "Ana"
)
.prosjek(4.8)
.build();

System.out.println("Student 1: " + student1.getIme());
System.out.println("Student 2: " + student2.getIme());
}
}

Builder Pattern - Prednosti

âœ… Prednosti

ÄŒitljiviji kod
Nema null parametara
Immutable objekti
Fleksibilnost pri kreiranju
LakÅ¡a validacija

ğŸ’¡ Kada koristiti

Klase s >4 parametra
Mnogo opcionalnih parametara
Kompleksno kreiranje objekta
Potreba za immutability

ğŸ¯ Moderne alternative: Java Records (Java 14+) mogu zamijeniti Builder Pattern u jednostavnijim sluÄajevima

ğŸ“Š Usporedba: Tradicionalno vs. Builder

âŒ Tradicionalni konstruktor
// TeÅ¡ko Äitljivo
Student s = new Student(
"123",
"Horvat",
"Ivan",
null,  // email?
null,  // telefon?
"Zagreb",
4.5
);

// Å to je Å¡to?!

âœ… Builder Pattern
// Jasno i Äitljivo
Student s = new Student
.StudentBuilder(
"123",
"Horvat",
"Ivan"
)
.grad("Zagreb")
.prosjek(4.5)
.build();

ğŸ“š Rekapitulacija

Å to smo nauÄili danas:

âœ… PraktiÄne primjere nasljeÄ‘ivanja (Vozilo, Instrumenti)
âœ… Polimorfizam u akciji
âœ… Implementaciju i koriÅ¡tenje suÄelja
âœ… NadjaÄavanje metoda u hijerarhiji
âœ… toString() metodu
âœ… Sortiranje s lambda izrazima
âœ… Pattern matching za instanceof (Java 16+)
âœ… Builder Pattern za elegantno kreiranje objekata

âœ… OOP Best Practices

Uvijek koristite:

@Override anotaciju
toString() za debugging
Pattern matching umjesto castanja
Lambda izraze za jednostavniji kod
Builder za kompleksne objekte

Izbjegavajte:

Duboke hijerarhije (>3 razine)
Castanje bez instanceof
PreviÅ¡e parametara u konstruktoru
Null parametri

Java 25
OOP
Design Patterns

ğŸ“‹ SadrÅ¾aj prezentacije

Osnovni koncepti

NasljeÄ‘ivanje meÄ‘u klasama
Nadklase i podklase
Modifikator protected
KljuÄna rijeÄ super
Konstruktori u podklasama

Napredne znaÄajke

Polimorfizam
Apstraktne klase
SuÄelja (Interfaces)
Lambda izrazi (Java 8+)
Records i Sealed klase

ğŸ§¬ NasljeÄ‘ivanje meÄ‘u klasama

NasljeÄ‘ivanje omoguÄ‡ava kreiranje novih klasa koje koriste Älanove veÄ‡ postojeÄ‡ih klasa

KljuÄni pojmovi:

Nadklasa (superclass) - postojeÄ‡a klasa
Podklasa (subclass) - nova klasa koja nasljeÄ‘uje
Podklasa dodaje nove znaÄajke i modificira ponaÅ¡anje nadklase
Sve klase u Javi nasljeÄ‘uju java.lang.Object

âš ï¸ VaÅ¾no: Java podrÅ¾ava samo jednostruko nasljeÄ‘ivanje - svaka klasa moÅ¾e nasljeÄ‘ivati samo jednu nadklasu!

Primjer nasljeÄ‘ivanja
// Nadklasa - opÄ‡enita klasa
public class BankovniKredit {
protected double iznos;
protected double kamatnaStopa;
protected int rokOtplate;

public double izracunajMjesecnuRatu() {
// Osnovna formula za izraÄun rate
return iznos * (1 + kamatnaStopa) / rokOtplate;
}
}

// Podklasa - specifiÄnija implementacija
public class KreditZaAuto extends BankovniKredit {
private String markaAutomobila;
private int godinaProizvodnje;

@Override
public double izracunajMjesecnuRatu() {
// Poseban izraÄun za auto kredite
double osnovnaRata = super.izracunajMjesecnuRatu();
return osnovnaRata * 0.95; // 5% popusta
}
}

ğŸ‘¥ Nadklase i podklase - Primjeri

Nadklasa
Podklase

Student
Apsolvent, DodiplomskiStudent, PostdiplomskiStudent

Oblik
Krug, Trokut, Pravokutnik, Kugla, Kocka

BankovniKredit
KreditZaAuto, HipotekarniKredit, GotovinsKredit

Zaposlenik
NastavnickoOsoblje, PomocnoOsoblje, Administrator

BankovniRacun
TekuciRacun, Ziroracun, StedniRacun

ğŸ’¡ Pravilo: Podklasa "JE" vrsta nadklase (npr. Student JE ClanZajednice)

ğŸŒ³ Hijerarhija nasljeÄ‘ivanja

Odnosi izmeÄ‘u klasa prikazuju se UML Class dijagramima

ğŸ“Š UML Dijagram: ClanZajednice â†’ Student â†’ Apsolvent
ğŸ“Š ClanZajednice â†’ Zaposlenik â†’ NastavnickoOsoblje â†’ Profesor

"JE" veza (is-a)
Student JE ClanZajednice
Profesor JE Zaposlenik

"IMA" veza (has-a)
Knjiga IMA Autora
Zaposlenik IMA DatumRodjenja

ğŸ” Modifikatori pristupa

Modifikator
Pristup

public
Dostupno svugdje

protected
Dostupno u podklasama i istom paketu

private
Dostupno samo unutar klase

(bez modifikatora)
Package-private - samo isti paket

ğŸ’¡ Best practice: Koristite protected za Älanove koje podklase trebaju moÄ‡i mijenjati!

â¬†ï¸ KljuÄna rijeÄ super

KoriÅ¡tenje:

super - referenca na nadklasu
this - referenca na trenutnu klasu

public class DvodimenzionalniOblik {
protected double visina;
protected double sirina;

public DvodimenzionalniOblik(double v, double s) {
this.visina = v;
this.sirina = s;
}
}

public class Pravokutnik extends DvodimenzionalniOblik {

public Pravokutnik(double v, double s) {
// Poziv konstruktora nadklase
super(v, s);
}

public double getVisina() {
// Pristup varijabli nadklase
return super.visina;
}
}

ğŸ—ï¸ Konstruktori u podklasamas

âš ï¸ VaÅ¾no pravilo: Prva naredba svakog konstruktora podklase je super()

public class Zaposlenik {
private String ime;

public Zaposlenik(String ime) {
this.ime = ime;
}
}

public class Profesor extends Zaposlenik {
private String katedra;

public Profesor(String ime, String katedra) {
// MORA biti prva naredba!
super(ime);
this.katedra = katedra;
}
}

Konstruktori se pozivaju ulanÄano - od nadklase prema podklasi

ğŸ”„ NadjaÄavanje metoda (@Override)
public class DvodimenzionalniOblik {
private double visina;
private double sirina;

public double izracunajPovrsinu() {
return visina * sirina;
}
}

public class Krug extends DvodimenzionalniOblik {
private double polumjer;

// Anotacija oznaÄava nadjaÄavanje
@Override
public double izracunajPovrsinu() {
return Math.PI * Math.pow(polumjer, 2);
}
}

âœ… Prednosti @Override: Kompajler provjerava da li pravilno nadjaÄavate metodu i javlja greÅ¡ku ako nije!

ğŸ”· Klasa java.lang.Object

Sve klase u Javi nasljeÄ‘uju Object - "majka svih klasa"

Metoda
Opis

equals()
Usporedba objekata (preporuÄeno nadjaÄati!)

hashCode()
Hash vrijednost objekta (za kolekcije)

toString()
String reprezentacija objekta

clone()
Kopiranje objekta

wait(), notify()
Rad s nitima i sinkronizacija

NadjaÄavanje equals() i hashCode()
public class Student {
private String oib;
private String ime;

@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass())
return false;
Student student = (Student) obj;
return Objects.equals(oib, student.oib);
}

@Override
public int hashCode() {
return Objects.hash(oib);
}

@Override
public String toString() {
return "Student{oib='" + oib + "', ime='" + ime + "'}";
}
}

ğŸ’¡ Pravilo: Ako nadjaÄate equals(), morate nadjaÄati i hashCode()!

ğŸ­ Polimorfizam

Polimorfizam = "Mnogo oblika" - ista metoda, razliÄito ponaÅ¡anje

Prednosti polimorfizma:

âœ… OpÄ‡enito programiranje umjesto specifiÄnog
âœ… LakÅ¡e proÅ¡irivanje sustava
âœ… Tipovi se odreÄ‘uju tijekom izvoÄ‘enja
âœ… Fleksibilniji kod

// Polje razliÄitih oblika
Oblik[] oblici = new Oblik[3];
oblici[0] = new Krug(5.0);
oblici[1] = new Pravokutnik(4.0, 6.0);
oblici[2] = new Trokut(3.0, 4.0, 5.0);

// Polimorfizam - razliÄite implementacije
for (Oblik oblik : oblici) {
System.out.println("PovrÅ¡ina: " + oblik.izracunajPovrsinu());
}

ğŸ”„ Casting objekata
// Upcasting (implicitno)
Oblik oblik = new Krug(5.0);  // Automatski

// Downcasting (eksplicitno - opasno!)
Krug krug = (Krug) oblik;
krug.setPolumjer(10.0);

// Sigurna provjera prije castinga
if (oblik instanceof Krug) {
Krug k = (Krug) oblik;
System.out.println("Polumjer: " + k.getPolumjer());
}

// Java 16+ - Pattern matching
if (oblik instanceof Krug k) {
// Varijabla 'k' je automatski dostupna!
System.out.println("Polumjer: " + k.getPolumjer());
}

âœ¨ Java 16+: Pattern matching za instanceof - kraÄ‡i i Äitljiviji kod!

ğŸ¨ Apstraktne klase

âš ï¸ VaÅ¾no: Iz apstraktnih klasa nije moguÄ‡e kreirati objekte!

public abstract class Oblik {
protected String naziv;

// ObiÄna metoda s implementacijom
public String getNaziv() {
return naziv;
}

// Apstraktna metoda - BEZ implementacije
public abstract double izracunajPovrsinu();
public abstract double izracunajOpseg();
}

public class Krug extends Oblik {
private double polumjer;

// MORA implementirati sve apstraktne metode
@Override
public double izracunajPovrsinu() {
return Math.PI * polumjer * polumjer;
}

@Override
public double izracunajOpseg() {
return 2 * Math.PI * polumjer;
}
}

Apstraktne klase - Pravila

âœ… KljuÄna pravila:

OznaÄava se kljuÄnom rijeÄju abstract
MoÅ¾e sadrÅ¾avati i obiÄne i apstraktne metode
Ako ima barem jednu apstraktnu metodu â†’ klasa MORA biti apstraktna
Podklase MORAJU implementirati sve apstraktne metode
Ako podklasa ne implementira sve â†’ i ona mora biti apstraktna
Mogu imati vlastiti konstruktor

ğŸ’¡ Kada koristiti: Kada Å¾elite definirati zajedniÄko ponaÅ¡anje, ali implementacija ovisi o konkretnom tipu objekta

ğŸ”’ KljuÄna rijeÄ final

Final klase
// SprjeÄava nasljeÄ‘ivanje
public final class String {
// ...
}

// GREÅ KA - ne moÅ¾e se naslijediti!
public class MyString
extends String {
}

Final metode
public class Osoba {
// SprjeÄava nadjaÄavanje
public final String getOIB() {
return oib;
}
}

// GREÅ KA!
@Override
public String getOIB() {
// ...
}

Final varijable (konstante)
public static final double PI = 3.14159265359;
public static final String NAZIV_DRZAVE = "Hrvatska";
private final int MAX_STUDENTS = 100;  // Ne moÅ¾e se mijenjati

ğŸ“‹ Definiranje suÄelja (Interfaces)

SuÄelja definiraju "ugovor" - koje metode klasa mora implementirati

// Definiranje suÄelja
public interface Elektricno {
// Konstantne vrijednosti (public static final)
int MAX_NAPON = 230;

// Apstraktne metode (public abstract)
void ukljuci();
void iskljuci();
boolean jeUkljuceno();
}

// Implementiranje suÄelja
public class ElektricnaGitara extends Gitara
implements Elektricno {

private boolean ukljucena;

@Override
public void ukljuci() {
ukljucena = true;
System.out.println("Gitara ukljuÄena!");
}

@Override
public void iskljuci() {
ukljucena = false;
}

@Override
public boolean jeUkljuceno() {
return ukljucena;
}
}

ğŸ”— ViÅ¡estruka implementacija suÄelja

âœ¨ KljuÄna razlika: Klasa moÅ¾e implementirati viÅ¡e suÄelja, ali naslijediti samo jednu klasu!

public interface Plivajuce {
void pliva();
}

public interface Letece {
void leti();
}

public interface Trkace {
void trci();
}

// Implementira VIÅ E suÄelja!
public class Patka extends Zivotinja
implements Plivajuce, Letece, Trkace {

@Override
public void pliva() {
System.out.println("Patka pliva!");
}

@Override
public void leti() {
System.out.println("Patka leti!");
}

@Override
public void trci() {
System.out.println("Patka trÄi!");
}
}

âœ¨ Java 8: Default metode u suÄeljima

Novost u Java 8: SuÄelja mogu imati metode s implementacijom!

public interface PracenjeVremena {

// Default metoda - ima implementaciju
default String dohvatiDatumVrijeme() {
LocalDateTime now = LocalDateTime.now();
return now.format(
DateTimeFormatter.ofPattern("dd.MM.yyyy. HH:mm:ss")
);
}

// Apstraktna metoda
void zabiljeziAktivnost(String opis);
}

public class Zadatak implements PracenjeVremena {

// MoÅ¾e koristiti default implementaciju
public void ispisi() {
System.out.println("Vrijeme: " + dohvatiDatumVrijeme());
}

// ILI nadjaÄati default metodu
@Override
public String dohvatiDatumVrijeme() {
return "Custom format...";
}

@Override
public void zabiljeziAktivnost(String opis) {
// Implementacija...
}
}

Java 8: StatiÄke metode u suÄeljima
public interface Provjera {

// StatiÄka metoda u suÄelju
static boolean provjeriPrazanString(String tekst) {
return tekst == null || tekst.isEmpty();
}

static boolean provjeriEmail(String email) {
return email != null && email.contains("@");
}
}

// KoriÅ¡tenje - direktno iz suÄelja!
public class Main {
public static void main(String[] args) {
String ime = "";

// Poziv statiÄke metode iz suÄelja
if (Provjera.provjeriPrazanString(ime)) {
System.out.println("Ime je prazno!");
}

String email = "student@foi.hr";
if (Provjera.provjeriEmail(email)) {
System.out.println("Email je valjan!");
}
}
}

ğŸš€ Java 8: Lambda izrazi

Lambda izrazi = skraÄ‡ena sintaksa za anonimne metode

Stari naÄin
// Anonimna klasa
Comparator comp =
new Comparator() {
@Override
public int compare(String s1,
String s2) {
return s1.length() -
s2.length();
}
};

Lambda naÄin
// Lambda izraz
Comparator comp =
(s1, s2) ->
s1.length() - s2.length();

// JoÅ¡ kraÄ‡e!
Comparator comp2 =
Comparator.comparingInt(
String::length
);

Sintaksa: (parametri) -> { tijelo }

Funkcionalna suÄelja i Lambda
// Funkcionalno suÄelje - samo JEDNA apstraktna metoda
@FunctionalInterface
public interface Kalkulator {
int izracunaj(int a, int b);
}

public class Main {
public static void main(String[] args) {
// Lambda izrazi za razliÄite operacije
Kalkulator zbroj = (a, b) -> a + b;
Kalkulator razlika = (a, b) -> a - b;
Kalkulator umnozak = (a, b) -> a * b;
Kalkulator dijeljenje = (a, b) -> a / b;

System.out.println("Zbroj: " + zbroj.izracunaj(10, 5));
System.out.println("Razlika: " + razlika.izracunaj(10, 5));
System.out.println("UmnoÅ¾ak: " + umnozak.izracunaj(10, 5));

// Primjena na liste
List brojevi = Arrays.asList(1, 2, 3, 4, 5);
brojevi.forEach(broj -> System.out.println(broj * 2));
}
}

âœ¨ Java 9: Privatne metode u suÄeljima
public interface Sucelje {

// Privatna metoda - moÅ¾e koristiti samo interno
private void test() {
System.out.println("Privatna metoda");
}

// StatiÄka metoda
public static void test2() {
System.out.println("Javna statiÄka metoda");
}

// Default metoda koja poziva privatnu
public default void test3() {
test();  // Poziv privatne metode
System.out.println("Default metoda");
}
}

ğŸ’¡ Svrha: Privatne metode omoguÄ‡avaju dijeljenje koda meÄ‘u default metodama bez da ih izlaÅ¾u van suÄelja

ğŸ¯ Java 14: Records

Records = kompaktni, nepromjenjivi (immutable) nositelji podataka

Stari naÄin
public class Person {
private final String name;
private final String address;

public Person(String name,
String address) {
this.name = name;
this.address = address;
}

public String getName() {
return name;
}

public String getAddress() {
return address;
}

// + equals, hashCode,
// toString...
}

Records naÄin
// Automatski generira:
// - konstruktor
// - getters
// - equals()
// - hashCode()
// - toString()
public record Person(
String name,
String address
) {}

// KoriÅ¡tenje
Person p = new Person(
"Ana",
"Zagreb"
);
System.out.println(
p.name()
);

âœ¨ Prednosti: Manje koda, thread-safe, savrÅ¡eno za DTO objekte!

Records - Dodatne moguÄ‡nosti
public record Student(
String oib,
String ime,
String prezime,
double prosjek
) {
// Kompaktni konstruktor - validacija
public Student {
if (oib == null || oib.length() != 11) {
throw new IllegalArgumentException("Neispravan OIB!");
}
if (prosjek < 1.0 || prosjek > 5.0) {
throw new IllegalArgumentException("Prosjek mora biti 1-5!");
}
}

// Dodatne metode
public String punoIme() {
return ime + " " + prezime;
}

public boolean jeDobitan() {
return prosjek >= 4.0;
}

// StatiÄke metode
public static Student kreirajDefault() {
return new Student("00000000000", "N/A", "N/A", 2.0);
}
}

ğŸ” Java 17: Sealed klase i suÄelja

Sealed klase omoguÄ‡avaju kontrolu koje klase mogu nasljeÄ‘ivati/implementirati

// Sealed suÄelje - SAMO Car i Truck mogu implementirati!
public sealed interface Service
permits Car, Truck {

int getMaxServiceIntervalInMonths();

default int getMaxDistanceBetweenServicesInKilometers() {
return 100000;
}
}

// Sealed apstraktna klasa
public abstract sealed class Vehicle
permits Car, Truck {

protected final String registrationNumber;

public Vehicle(String registrationNumber) {
this.registrationNumber = registrationNumber;
}

public String getRegistrationNumber() {
return registrationNumber;
}
}

Sealed klase - Implementacija

Final implementacija
// FINAL - ne moÅ¾e se dalje
// nasljeÄ‘ivati
public final class Truck
extends Vehicle
implements Service {

private final int loadCapacity;

public Truck(int load,
String regNum) {
super(regNum);
this.loadCapacity = load;
}

@Override
public int
getMaxServiceIntervalInMonths() {
return 18;
}
}

Non-sealed implementacija
// NON-SEALED - moÅ¾e se dalje
// nasljeÄ‘ivati
public non-sealed class Car
extends Vehicle
implements Service {

private final int numberOfSeats;

public Car(int seats,
String regNum) {
super(regNum);
this.numberOfSeats = seats;
}

@Override
public int
getMaxServiceIntervalInMonths() {
return 12;
}
}

ğŸ’¡ Koristi: Bolja kontrola nad hijerarhijom, sigurnija API dizajna, pattern matching

ğŸ“Š Usporedba OOP koncepata

Koncept
Kada koristiti
Primjer

Apstraktna klasa
ZajedniÄka implementacija + apstraktne metode
Oblik, Zivotinja

Interface
Ugovor bez implementacije, viÅ¡estruka impl.
Comparable, Serializable

Record
Nepromjenjivi nositelji podataka (DTO)
Person, Student

Sealed class
Kontrolirana hijerarhija
Vehicle, Shape

Final class
SprjeÄavanje nasljeÄ‘ivanja
String, Math

âœ… OOP Best Practices

DO âœ…

Koristiti @Override anotaciju
NadjaÄati equals() i hashCode() zajedno
Favorizirati kompoziciju nad nasljeÄ‘ivanjem
Koristiti suÄelja za fleksibilnost
Records za DTO objekte
Sealed klase za kontroliranu hijerarhiju

DON'T âŒ

Duboke hijerarhije nasljeÄ‘ivanja
Pretjerano koriÅ¡tenje nasljeÄ‘ivanja
Zaboraviti super() u konstruktoru
Casting bez instanceof provjere
Javne promjenjive varijable u klasama
Zanemariti princip SRP


